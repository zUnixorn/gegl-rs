// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ../..
// from ../../gir-files
// DO NOT EDIT

#![allow(non_camel_case_types, non_upper_case_globals, non_snake_case)]
#![allow(clippy::approx_constant, clippy::type_complexity, clippy::unreadable_literal, clippy::upper_case_acronyms)]
#![cfg_attr(docsrs, feature(doc_cfg))]

use babl_sys as babl;
use glib_sys as glib;
use gobject_sys as gobject;

#[allow(unused_imports)]
use std::ffi::{c_int, c_char, c_uchar, c_float, c_uint, c_double,
    c_short, c_ushort, c_long, c_ulong, c_void};
#[allow(unused_imports)]
use libc::{size_t, ssize_t, time_t, off_t, intptr_t, uintptr_t, FILE};
#[cfg(unix)]
#[allow(unused_imports)]
use libc::{dev_t, gid_t, pid_t, socklen_t, uid_t};

#[allow(unused_imports)]
use glib::{gboolean, gconstpointer, gpointer, GType};

// Enums
pub type GeglAbyssPolicy = c_int;
pub const GEGL_ABYSS_NONE: GeglAbyssPolicy = 0;
pub const GEGL_ABYSS_CLAMP: GeglAbyssPolicy = 1;
pub const GEGL_ABYSS_LOOP: GeglAbyssPolicy = 2;
pub const GEGL_ABYSS_BLACK: GeglAbyssPolicy = 3;
pub const GEGL_ABYSS_WHITE: GeglAbyssPolicy = 4;

pub type GeglBablVariant = c_int;
pub const GEGL_BABL_VARIANT_FLOAT: GeglBablVariant = 0;
pub const GEGL_BABL_VARIANT_LINEAR: GeglBablVariant = 1;
pub const GEGL_BABL_VARIANT_NONLINEAR: GeglBablVariant = 2;
pub const GEGL_BABL_VARIANT_PERCEPTUAL: GeglBablVariant = 3;
pub const GEGL_BABL_VARIANT_LINEAR_PREMULTIPLIED: GeglBablVariant = 4;
pub const GEGL_BABL_VARIANT_PERCEPTUAL_PREMULTIPLIED: GeglBablVariant = 5;
pub const GEGL_BABL_VARIANT_LINEAR_PREMULTIPLIED_IF_ALPHA: GeglBablVariant = 6;
pub const GEGL_BABL_VARIANT_PERCEPTUAL_PREMULTIPLIED_IF_ALPHA: GeglBablVariant = 7;
pub const GEGL_BABL_VARIANT_ALPHA: GeglBablVariant = 8;

pub type GeglCachePolicy = c_int;
pub const GEGL_CACHE_POLICY_AUTO: GeglCachePolicy = 0;
pub const GEGL_CACHE_POLICY_NEVER: GeglCachePolicy = 1;
pub const GEGL_CACHE_POLICY_ALWAYS: GeglCachePolicy = 2;

pub type GeglDistanceMetric = c_int;
pub const GEGL_DISTANCE_METRIC_EUCLIDEAN: GeglDistanceMetric = 0;
pub const GEGL_DISTANCE_METRIC_MANHATTAN: GeglDistanceMetric = 1;
pub const GEGL_DISTANCE_METRIC_CHEBYSHEV: GeglDistanceMetric = 2;

pub type GeglDitherMethod = c_int;
pub const GEGL_DITHER_NONE: GeglDitherMethod = 0;
pub const GEGL_DITHER_FLOYD_STEINBERG: GeglDitherMethod = 1;
pub const GEGL_DITHER_BAYER: GeglDitherMethod = 2;
pub const GEGL_DITHER_RANDOM: GeglDitherMethod = 3;
pub const GEGL_DITHER_RANDOM_COVARIANT: GeglDitherMethod = 4;
pub const GEGL_DITHER_ARITHMETIC_ADD: GeglDitherMethod = 5;
pub const GEGL_DITHER_ARITHMETIC_ADD_COVARIANT: GeglDitherMethod = 6;
pub const GEGL_DITHER_ARITHMETIC_XOR: GeglDitherMethod = 7;
pub const GEGL_DITHER_ARITHMETIC_XOR_COVARIANT: GeglDitherMethod = 8;
pub const GEGL_DITHER_BLUE_NOISE: GeglDitherMethod = 9;
pub const GEGL_DITHER_BLUE_NOISE_COVARIANT: GeglDitherMethod = 10;

pub type GeglMapFlags = c_int;
pub const GEGL_MAP_EXCLUDE_UNMAPPED: GeglMapFlags = 1;

pub type GeglOrientation = c_int;
pub const GEGL_ORIENTATION_HORIZONTAL: GeglOrientation = 0;
pub const GEGL_ORIENTATION_VERTICAL: GeglOrientation = 1;

pub type GeglRectangleAlignment = c_int;
pub const GEGL_RECTANGLE_ALIGNMENT_SUBSET: GeglRectangleAlignment = 0;
pub const GEGL_RECTANGLE_ALIGNMENT_SUPERSET: GeglRectangleAlignment = 1;
pub const GEGL_RECTANGLE_ALIGNMENT_NEAREST: GeglRectangleAlignment = 2;

pub type GeglResolutionUnit = c_int;
pub const GEGL_RESOLUTION_UNIT_NONE: GeglResolutionUnit = 0;
pub const GEGL_RESOLUTION_UNIT_DPI: GeglResolutionUnit = 1;
pub const GEGL_RESOLUTION_UNIT_DPM: GeglResolutionUnit = 2;

pub type GeglSamplerType = c_int;
pub const GEGL_SAMPLER_NEAREST: GeglSamplerType = 0;
pub const GEGL_SAMPLER_LINEAR: GeglSamplerType = 1;
pub const GEGL_SAMPLER_CUBIC: GeglSamplerType = 2;
pub const GEGL_SAMPLER_NOHALO: GeglSamplerType = 3;
pub const GEGL_SAMPLER_LOHALO: GeglSamplerType = 4;

pub type GeglSplitStrategy = c_int;
pub const GEGL_SPLIT_STRATEGY_AUTO: GeglSplitStrategy = 0;
pub const GEGL_SPLIT_STRATEGY_HORIZONTAL: GeglSplitStrategy = 1;
pub const GEGL_SPLIT_STRATEGY_VERTICAL: GeglSplitStrategy = 2;

pub type GeglTileCommand = c_int;
pub const GEGL_TILE_IDLE: GeglTileCommand = 0;
pub const GEGL_TILE_SET: GeglTileCommand = 1;
pub const GEGL_TILE_GET: GeglTileCommand = 2;
pub const GEGL_TILE_IS_CACHED: GeglTileCommand = 3;
pub const GEGL_TILE_EXIST: GeglTileCommand = 4;
pub const GEGL_TILE_VOID: GeglTileCommand = 5;
pub const GEGL_TILE_FLUSH: GeglTileCommand = 6;
pub const GEGL_TILE_REFETCH: GeglTileCommand = 7;
pub const GEGL_TILE_REINIT: GeglTileCommand = 8;
pub const _GEGL_TILE_LAST_0_4_8_COMMAND: GeglTileCommand = 9;
pub const GEGL_TILE_COPY: GeglTileCommand = 9;
pub const GEGL_TILE_LAST_COMMAND: GeglTileCommand = 10;

// Constants
pub const GEGL_AUTO_ROWSTRIDE: c_int = 0;
pub const GEGL_CH_BACK_CENTER: c_int = 256;
pub const GEGL_CH_BACK_LEFT: c_int = 16;
pub const GEGL_CH_BACK_RIGHT: c_int = 32;
pub const GEGL_CH_FRONT_CENTER: c_int = 4;
pub const GEGL_CH_FRONT_LEFT: c_int = 1;
pub const GEGL_CH_FRONT_LEFT_OF_CENTER: c_int = 64;
pub const GEGL_CH_FRONT_RIGHT: c_int = 2;
pub const GEGL_CH_FRONT_RIGHT_OF_CENTER: c_int = 128;
pub const GEGL_CH_LAYOUT_2POINT1: c_int = 11;
pub const GEGL_CH_LAYOUT_2_1: c_int = 259;
pub const GEGL_CH_LAYOUT_2_2: c_int = 1539;
pub const GEGL_CH_LAYOUT_3POINT1: c_int = 15;
pub const GEGL_CH_LAYOUT_4POINT0: c_int = 263;
pub const GEGL_CH_LAYOUT_4POINT1: c_int = 271;
pub const GEGL_CH_LAYOUT_5POINT0: c_int = 1543;
pub const GEGL_CH_LAYOUT_5POINT0_BACK: c_int = 55;
pub const GEGL_CH_LAYOUT_5POINT1: c_int = 1551;
pub const GEGL_CH_LAYOUT_5POINT1_BACK: c_int = 63;
pub const GEGL_CH_LAYOUT_6POINT0: c_int = 1799;
pub const GEGL_CH_LAYOUT_6POINT0_FRONT: c_int = 1731;
pub const GEGL_CH_LAYOUT_6POINT1: c_int = 1807;
pub const GEGL_CH_LAYOUT_6POINT1_BACK: c_int = 319;
pub const GEGL_CH_LAYOUT_6POINT1_FRONT: c_int = 1739;
pub const GEGL_CH_LAYOUT_7POINT0: c_int = 1591;
pub const GEGL_CH_LAYOUT_7POINT0_FRONT: c_int = 1735;
pub const GEGL_CH_LAYOUT_7POINT1: c_int = 1599;
pub const GEGL_CH_LAYOUT_7POINT1_WIDE: c_int = 1743;
pub const GEGL_CH_LAYOUT_7POINT1_WIDE_BACK: c_int = 255;
pub const GEGL_CH_LAYOUT_HEXADECAGONAL: c_long = 6442710839;
pub const GEGL_CH_LAYOUT_HEXAGONAL: c_int = 311;
pub const GEGL_CH_LAYOUT_NATIVE: u64 = 9223372036854775808;
pub const GEGL_CH_LAYOUT_OCTAGONAL: c_int = 1847;
pub const GEGL_CH_LAYOUT_QUAD: c_int = 51;
pub const GEGL_CH_LAYOUT_STEREO: c_int = 3;
pub const GEGL_CH_LAYOUT_STEREO_DOWNMIX: c_int = 1610612736;
pub const GEGL_CH_LAYOUT_SURROUND: c_int = 7;
pub const GEGL_CH_LOW_FREQUENCY: c_int = 8;
pub const GEGL_CH_LOW_FREQUENCY_2: c_long = 34359738368;
pub const GEGL_CH_SIDE_LEFT: c_int = 512;
pub const GEGL_CH_SIDE_RIGHT: c_int = 1024;
pub const GEGL_CH_STEREO_LEFT: c_int = 536870912;
pub const GEGL_CH_STEREO_RIGHT: c_int = 1073741824;
pub const GEGL_CH_SURROUND_DIRECT_LEFT: c_long = 8589934592;
pub const GEGL_CH_SURROUND_DIRECT_RIGHT: c_long = 17179869184;
pub const GEGL_CH_TOP_BACK_CENTER: c_int = 65536;
pub const GEGL_CH_TOP_BACK_LEFT: c_int = 32768;
pub const GEGL_CH_TOP_BACK_RIGHT: c_int = 131072;
pub const GEGL_CH_TOP_CENTER: c_int = 2048;
pub const GEGL_CH_TOP_FRONT_CENTER: c_int = 8192;
pub const GEGL_CH_TOP_FRONT_LEFT: c_int = 4096;
pub const GEGL_CH_TOP_FRONT_RIGHT: c_int = 16384;
pub const GEGL_CH_WIDE_LEFT: c_long = 2147483648;
pub const GEGL_CH_WIDE_RIGHT: c_long = 4294967296;
pub const GEGL_FLOAT_EPSILON: c_double = 0.000010;
pub const GEGL_LOOKUP_MAX_ENTRIES: c_int = 819200;
pub const GEGL_MAJOR_VERSION: c_int = 0;
pub const GEGL_MAX_AUDIO_CHANNELS: c_int = 8;
pub const GEGL_MICRO_VERSION: c_int = 44;
pub const GEGL_MINOR_VERSION: c_int = 4;
pub const GEGL_PARAM_NO_VALIDATE: c_int = 64;

// Flags
pub type GeglAccessMode = c_uint;
pub const GEGL_ACCESS_READ: GeglAccessMode = 1;
pub const GEGL_ACCESS_WRITE: GeglAccessMode = 2;
pub const GEGL_ACCESS_READWRITE: GeglAccessMode = 3;

pub type GeglBlitFlags = c_uint;
pub const GEGL_BLIT_DEFAULT: GeglBlitFlags = 0;
pub const GEGL_BLIT_CACHE: GeglBlitFlags = 1;
pub const GEGL_BLIT_DIRTY: GeglBlitFlags = 2;

pub type GeglPadType = c_uint;
pub const GEGL_PARAM_PAD_OUTPUT: GeglPadType = 256;
pub const GEGL_PARAM_PAD_INPUT: GeglPadType = 512;

pub type GeglSerializeFlag = c_uint;
pub const GEGL_SERIALIZE_TRIM_DEFAULTS: GeglSerializeFlag = 1;
pub const GEGL_SERIALIZE_VERSION: GeglSerializeFlag = 2;
pub const GEGL_SERIALIZE_INDENT: GeglSerializeFlag = 4;
pub const GEGL_SERIALIZE_BAKE_ANIM: GeglSerializeFlag = 8;

// Callbacks
pub type GeglFlattenerFunc = Option<unsafe extern "C" fn(*mut GeglPathList) -> *mut GeglPathList>;
pub type GeglLookupFunction = Option<unsafe extern "C" fn(c_float, gpointer) -> c_float>;
pub type GeglNodeFunction = Option<unsafe extern "C" fn(*const GeglPathItem, gpointer)>;
pub type GeglParallelDistributeAreaFunc = Option<unsafe extern "C" fn(*const GeglRectangle, gpointer)>;
pub type GeglParallelDistributeFunc = Option<unsafe extern "C" fn(c_int, c_int, gpointer)>;
pub type GeglParallelDistributeRangeFunc = Option<unsafe extern "C" fn(size_t, size_t, gpointer)>;
pub type GeglSamplerGetFun = Option<unsafe extern "C" fn(*mut GeglSampler, c_double, c_double, *mut GeglBufferMatrix2, *mut c_void, GeglAbyssPolicy)>;
pub type GeglTileCallback = Option<unsafe extern "C" fn(*mut GeglTile, gpointer)>;
pub type GeglTileSourceCommand = Option<unsafe extern "C" fn(*mut GeglTileSource, GeglTileCommand, c_int, c_int, c_int, gpointer) -> gpointer>;

// Records
#[derive(Copy, Clone)]
#[repr(C)]
pub struct GeglAudioFragmentClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GeglAudioFragmentClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglAudioFragmentClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _GeglAudioFragmentPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GeglAudioFragmentPrivate = _GeglAudioFragmentPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GeglBufferIterator {
    pub length: c_int,
    pub priv_: *mut GeglBufferIteratorPriv,
}

impl ::std::fmt::Debug for GeglBufferIterator {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglBufferIterator @ {self:p}"))
         .field("length", &self.length)
         .field("priv_", &self.priv_)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GeglBufferIteratorItem {
    pub data: gpointer,
    pub roi: GeglRectangle,
}

impl ::std::fmt::Debug for GeglBufferIteratorItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglBufferIteratorItem @ {self:p}"))
         .field("data", &self.data)
         .field("roi", &self.roi)
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _GeglBufferIteratorPriv {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GeglBufferIteratorPriv = _GeglBufferIteratorPriv;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GeglBufferMatrix2 {
    pub coeff: [c_double; 4],
}

impl ::std::fmt::Debug for GeglBufferMatrix2 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglBufferMatrix2 @ {self:p}"))
         .field("coeff", &self.coeff)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GeglColorClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GeglColorClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglColorClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _GeglColorPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GeglColorPrivate = _GeglColorPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GeglCurveClass {
    pub parent_class: gobject::GObjectClass,
}

impl ::std::fmt::Debug for GeglCurveClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglCurveClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GeglLookup {
    pub function: GeglLookupFunction,
    pub data: gpointer,
    pub shift: c_int,
    pub positive_min: u32,
    pub positive_max: u32,
    pub negative_min: u32,
    pub negative_max: u32,
    pub bitmask: [u32; 25600],
    _truncated_record_marker: c_void,
    // /*Ignored*/field table has empty c:type
}

impl ::std::fmt::Debug for GeglLookup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglLookup @ {self:p}"))
         .field("function", &self.function)
         .field("data", &self.data)
         .field("shift", &self.shift)
         .field("positive_min", &self.positive_min)
         .field("positive_max", &self.positive_max)
         .field("negative_min", &self.negative_min)
         .field("negative_max", &self.negative_max)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GeglMatrix3 {
    pub coeff: [c_double; 9],
}

impl ::std::fmt::Debug for GeglMatrix3 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglMatrix3 @ {self:p}"))
         .field("coeff", &self.coeff)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GeglMetadataHashClass {
    pub parent_class: GeglMetadataStoreClass,
}

impl ::std::fmt::Debug for GeglMetadataHashClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglMetadataHashClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GeglMetadataInterface {
    pub base_iface: gobject::GTypeInterface,
    pub register_map: Option<unsafe extern "C" fn(*mut GeglMetadata, *const c_char, c_uint, *const GeglMetadataMap, size_t)>,
    pub set_resolution: Option<unsafe extern "C" fn(*mut GeglMetadata, *mut GeglResolutionUnit, *mut c_float, *mut c_float) -> gboolean>,
    pub get_resolution: Option<unsafe extern "C" fn(*mut GeglMetadata, *mut GeglResolutionUnit, *mut c_float, *mut c_float) -> gboolean>,
    pub iter_lookup: Option<unsafe extern "C" fn(*mut GeglMetadata, *mut GeglMetadataIter, *const c_char) -> gboolean>,
    pub iter_init: Option<unsafe extern "C" fn(*mut GeglMetadata, *mut GeglMetadataIter)>,
    pub iter_next: Option<unsafe extern "C" fn(*mut GeglMetadata, *mut GeglMetadataIter) -> *const c_char>,
    pub iter_set_value: Option<unsafe extern "C" fn(*mut GeglMetadata, *mut GeglMetadataIter, *mut gobject::GValue) -> gboolean>,
    pub iter_get_value: Option<unsafe extern "C" fn(*mut GeglMetadata, *mut GeglMetadataIter, *mut gobject::GValue) -> gboolean>,
}

impl ::std::fmt::Debug for GeglMetadataInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglMetadataInterface @ {self:p}"))
         .field("register_map", &self.register_map)
         .field("set_resolution", &self.set_resolution)
         .field("get_resolution", &self.get_resolution)
         .field("iter_lookup", &self.iter_lookup)
         .field("iter_init", &self.iter_init)
         .field("iter_next", &self.iter_next)
         .field("iter_set_value", &self.iter_set_value)
         .field("iter_get_value", &self.iter_get_value)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GeglMetadataIter {
    pub stamp: c_uint,
    pub user_data: gpointer,
    pub user_data2: gpointer,
    pub user_data3: gpointer,
}

impl ::std::fmt::Debug for GeglMetadataIter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglMetadataIter @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GeglMetadataMap {
    pub local_name: *const c_char,
    pub name: *const c_char,
    pub transform: gobject::GValueTransform,
}

impl ::std::fmt::Debug for GeglMetadataMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglMetadataMap @ {self:p}"))
         .field("local_name", &self.local_name)
         .field("name", &self.name)
         .field("transform", &self.transform)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GeglMetadataStoreClass {
    pub parent_class: gobject::GObjectClass,
    pub _declare: Option<unsafe extern "C" fn(*mut GeglMetadataStore, *mut gobject::GParamSpec, gboolean)>,
    pub pspec: Option<unsafe extern "C" fn(*mut GeglMetadataStore, *const c_char) -> *mut gobject::GParamSpec>,
    pub set_value: Option<unsafe extern "C" fn(*mut GeglMetadataStore, *const c_char, *const gobject::GValue)>,
    pub _get_value: Option<unsafe extern "C" fn(*mut GeglMetadataStore, *const c_char) -> *const gobject::GValue>,
    pub has_value: Option<unsafe extern "C" fn(*mut GeglMetadataStore, *const c_char) -> gboolean>,
    pub register_hook: Option<unsafe extern "C" fn(*mut GeglMetadataStore, *const c_char, c_uint)>,
    pub parse_value: Option<unsafe extern "C" fn(*mut GeglMetadataStore, *mut gobject::GParamSpec, gobject::GValueTransform, *mut gobject::GValue) -> gboolean>,
    pub generate_value: Option<unsafe extern "C" fn(*mut GeglMetadataStore, *mut gobject::GParamSpec, gobject::GValueTransform, *mut gobject::GValue) -> gboolean>,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for GeglMetadataStoreClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglMetadataStoreClass @ {self:p}"))
         .field("_declare", &self._declare)
         .field("pspec", &self.pspec)
         .field("set_value", &self.set_value)
         .field("_get_value", &self._get_value)
         .field("has_value", &self.has_value)
         .field("register_hook", &self.register_hook)
         .field("parse_value", &self.parse_value)
         .field("generate_value", &self.generate_value)
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _GeglOperationContext {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GeglOperationContext = _GeglOperationContext;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GeglParamSpecDouble {
    pub parent_instance: gobject::GParamSpecDouble,
    pub ui_minimum: c_double,
    pub ui_maximum: c_double,
    pub ui_gamma: c_double,
    pub ui_step_small: c_double,
    pub ui_step_big: c_double,
    pub ui_digits: c_int,
}

impl ::std::fmt::Debug for GeglParamSpecDouble {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglParamSpecDouble @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .field("ui_minimum", &self.ui_minimum)
         .field("ui_maximum", &self.ui_maximum)
         .field("ui_gamma", &self.ui_gamma)
         .field("ui_step_small", &self.ui_step_small)
         .field("ui_step_big", &self.ui_step_big)
         .field("ui_digits", &self.ui_digits)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GeglParamSpecEnum {
    pub parent_instance: gobject::GParamSpecEnum,
    pub excluded_values: *mut glib::GSList,
}

impl ::std::fmt::Debug for GeglParamSpecEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglParamSpecEnum @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .field("excluded_values", &self.excluded_values)
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GeglParamSpecFilePath {
    _truncated_record_marker: c_void,
    // /*Ignored*/field parent_instance has incomplete type
}

impl ::std::fmt::Debug for GeglParamSpecFilePath {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglParamSpecFilePath @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GeglParamSpecFormat {
    pub parent_instance: gobject::GParamSpecPointer,
}

impl ::std::fmt::Debug for GeglParamSpecFormat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglParamSpecFormat @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GeglParamSpecInt {
    pub parent_instance: gobject::GParamSpecInt,
    pub ui_minimum: c_int,
    pub ui_maximum: c_int,
    pub ui_gamma: c_double,
    pub ui_step_small: c_int,
    pub ui_step_big: c_int,
}

impl ::std::fmt::Debug for GeglParamSpecInt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglParamSpecInt @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .field("ui_minimum", &self.ui_minimum)
         .field("ui_maximum", &self.ui_maximum)
         .field("ui_gamma", &self.ui_gamma)
         .field("ui_step_small", &self.ui_step_small)
         .field("ui_step_big", &self.ui_step_big)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GeglParamSpecSeed {
    pub parent_instance: gobject::GParamSpecUInt,
    pub ui_minimum: c_uint,
    pub ui_maximum: c_uint,
}

impl ::std::fmt::Debug for GeglParamSpecSeed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglParamSpecSeed @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .field("ui_minimum", &self.ui_minimum)
         .field("ui_maximum", &self.ui_maximum)
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GeglParamSpecString {
    _truncated_record_marker: c_void,
    // /*Ignored*/field parent_instance has incomplete type
}

impl ::std::fmt::Debug for GeglParamSpecString {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglParamSpecString @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GeglParamSpecUri {
    _truncated_record_marker: c_void,
    // /*Ignored*/field parent_instance has incomplete type
}

impl ::std::fmt::Debug for GeglParamSpecUri {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglParamSpecUri @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _GeglPathClass {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GeglPathClass = _GeglPathClass;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GeglPathItem {
    pub type_: c_char,
    pub point: [GeglPathPoint; 4],
}

impl ::std::fmt::Debug for GeglPathItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglPathItem @ {self:p}"))
         .field("type_", &self.type_)
         .field("point", &self.point)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GeglPathList {
    pub next: *mut GeglPathList,
    pub d: GeglPathItem,
}

impl ::std::fmt::Debug for GeglPathList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglPathList @ {self:p}"))
         .field("next", &self.next)
         .field("d", &self.d)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GeglPathPoint {
    pub x: c_float,
    pub y: c_float,
}

impl ::std::fmt::Debug for GeglPathPoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglPathPoint @ {self:p}"))
         .field("x", &self.x)
         .field("y", &self.y)
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GeglRandom {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GeglRandom {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglRandom @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GeglRectangle {
    pub x: c_int,
    pub y: c_int,
    pub width: c_int,
    pub height: c_int,
}

impl ::std::fmt::Debug for GeglRectangle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglRectangle @ {self:p}"))
         .field("x", &self.x)
         .field("y", &self.y)
         .field("width", &self.width)
         .field("height", &self.height)
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _GeglSampler {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GeglSampler = _GeglSampler;

#[repr(C)]
#[allow(dead_code)]
pub struct _GeglTile {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GeglTile = _GeglTile;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GeglTileBackendClass {
    pub parent_class: GeglTileSourceClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for GeglTileBackendClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglTileBackendClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .field("padding", &self.padding)
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _GeglTileBackendPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GeglTileBackendPrivate = _GeglTileBackendPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GeglTileCopyParams {
    pub dst_buffer: *mut GeglBuffer,
    pub dst_x: c_int,
    pub dst_y: c_int,
    pub dst_z: c_int,
}

impl ::std::fmt::Debug for GeglTileCopyParams {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglTileCopyParams @ {self:p}"))
         .field("dst_buffer", &self.dst_buffer)
         .field("dst_x", &self.dst_x)
         .field("dst_y", &self.dst_y)
         .field("dst_z", &self.dst_z)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GeglTileHandlerClass {
    pub parent_class: GeglTileSourceClass,
}

impl ::std::fmt::Debug for GeglTileHandlerClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglTileHandlerClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct _GeglTileHandlerPrivate {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

pub type GeglTileHandlerPrivate = _GeglTileHandlerPrivate;

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GeglTileSourceClass {
    pub parent_class: gobject::GObjectClass,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for GeglTileSourceClass {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglTileSourceClass @ {self:p}"))
         .field("parent_class", &self.parent_class)
         .field("padding", &self.padding)
         .finish()
    }
}

// Classes
#[derive(Copy, Clone)]
#[repr(C)]
pub struct GeglAudioFragment {
    pub parent_instance: gobject::GObject,
    pub data: [*mut c_float; 8],
    pub priv_: *mut GeglAudioFragmentPrivate,
}

impl ::std::fmt::Debug for GeglAudioFragment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglAudioFragment @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .field("data", &self.data)
         .field("priv_", &self.priv_)
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GeglBuffer {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GeglBuffer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglBuffer @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GeglColor {
    pub parent_instance: gobject::GObject,
    pub priv_: *mut GeglColorPrivate,
}

impl ::std::fmt::Debug for GeglColor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglColor @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .field("priv_", &self.priv_)
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GeglConfig {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GeglConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglConfig @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GeglCurve {
    pub parent_instance: gobject::GObject,
}

impl ::std::fmt::Debug for GeglCurve {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglCurve @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GeglMetadataHash {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GeglMetadataHash {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglMetadataHash @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GeglMetadataStore {
    pub parent_instance: gobject::GObject,
}

impl ::std::fmt::Debug for GeglMetadataStore {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglMetadataStore @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GeglNode {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GeglNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglNode @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GeglOperation {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GeglOperation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglOperation @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GeglParamAudioFragment {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GeglParamAudioFragment {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglParamAudioFragment @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GeglParamColor {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GeglParamColor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglParamColor @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GeglParamCurve {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GeglParamCurve {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglParamCurve @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GeglParamDouble {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GeglParamDouble {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglParamDouble @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GeglParamEnum {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GeglParamEnum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglParamEnum @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GeglParamFilePath {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GeglParamFilePath {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglParamFilePath @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GeglParamFormat {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GeglParamFormat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglParamFormat @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GeglParamInt {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GeglParamInt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglParamInt @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GeglParamPath {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GeglParamPath {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglParamPath @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GeglParamSeed {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GeglParamSeed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglParamSeed @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GeglParamString {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GeglParamString {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglParamString @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GeglParamUri {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GeglParamUri {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglParamUri @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GeglPath {
    pub parent_instance: gobject::GObject,
}

impl ::std::fmt::Debug for GeglPath {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglPath @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GeglProcessor {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GeglProcessor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglProcessor @ {self:p}"))
         .finish()
    }
}

#[repr(C)]
#[allow(dead_code)]
pub struct GeglStats {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GeglStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglStats @ {self:p}"))
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GeglTileBackend {
    pub parent_instance: GeglTileSource,
    pub priv_: *mut GeglTileBackendPrivate,
}

impl ::std::fmt::Debug for GeglTileBackend {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglTileBackend @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .field("priv_", &self.priv_)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GeglTileHandler {
    pub parent_instance: GeglTileSource,
    pub source: *mut GeglTileSource,
    pub priv_: *mut GeglTileHandlerPrivate,
}

impl ::std::fmt::Debug for GeglTileHandler {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglTileHandler @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .field("source", &self.source)
         .field("priv_", &self.priv_)
         .finish()
    }
}

#[derive(Copy, Clone)]
#[repr(C)]
pub struct GeglTileSource {
    pub parent_instance: gobject::GObject,
    pub command: GeglTileSourceCommand,
    pub padding: [gpointer; 4],
}

impl ::std::fmt::Debug for GeglTileSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        f.debug_struct(&format!("GeglTileSource @ {self:p}"))
         .field("parent_instance", &self.parent_instance)
         .field("command", &self.command)
         .field("padding", &self.padding)
         .finish()
    }
}

// Interfaces
#[repr(C)]
#[allow(dead_code)]
pub struct GeglMetadata {
    _data: [u8; 0],
    _marker: core::marker::PhantomData<(*mut u8, core::marker::PhantomPinned)>,
}

impl ::std::fmt::Debug for GeglMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        write!(f, "GeglMetadata @ {self:p}")
    }
}


extern "C" {

    //=========================================================================
    // GeglAbyssPolicy
    //=========================================================================
    pub fn gegl_abyss_policy_get_type() -> GType;

    //=========================================================================
    // GeglBablVariant
    //=========================================================================
    pub fn gegl_babl_variant_get_type() -> GType;

    //=========================================================================
    // GeglCachePolicy
    //=========================================================================
    pub fn gegl_cache_policy_get_type() -> GType;

    //=========================================================================
    // GeglDistanceMetric
    //=========================================================================
    pub fn gegl_distance_metric_get_type() -> GType;

    //=========================================================================
    // GeglDitherMethod
    //=========================================================================
    pub fn gegl_dither_method_get_type() -> GType;

    //=========================================================================
    // GeglOrientation
    //=========================================================================
    pub fn gegl_orientation_get_type() -> GType;

    //=========================================================================
    // GeglRectangleAlignment
    //=========================================================================
    pub fn gegl_rectangle_alignment_get_type() -> GType;

    //=========================================================================
    // GeglResolutionUnit
    //=========================================================================
    pub fn gegl_resolution_unit_get_type() -> GType;

    //=========================================================================
    // GeglSamplerType
    //=========================================================================
    pub fn gegl_sampler_type_get_type() -> GType;

    //=========================================================================
    // GeglAccessMode
    //=========================================================================
    pub fn gegl_access_mode_get_type() -> GType;

    //=========================================================================
    // GeglBufferIterator
    //=========================================================================
    pub fn gegl_buffer_iterator_add(iterator: *mut GeglBufferIterator, buffer: *mut GeglBuffer, roi: *const GeglRectangle, level: c_int, format: *const babl::Babl, access_mode: GeglAccessMode, abyss_policy: GeglAbyssPolicy) -> c_int;
    pub fn gegl_buffer_iterator_next(iterator: *mut GeglBufferIterator) -> gboolean;
    pub fn gegl_buffer_iterator_stop(iterator: *mut GeglBufferIterator);
    pub fn gegl_buffer_iterator_empty_new(max_slots: c_int) -> *mut GeglBufferIterator;

    //=========================================================================
    // GeglBufferMatrix2
    //=========================================================================
    pub fn gegl_buffer_matrix2_determinant(matrix: *mut GeglBufferMatrix2) -> c_double;
    pub fn gegl_buffer_matrix2_is_identity(matrix: *mut GeglBufferMatrix2) -> gboolean;
    pub fn gegl_buffer_matrix2_is_scale(matrix: *mut GeglBufferMatrix2) -> gboolean;

    //=========================================================================
    // GeglLookup
    //=========================================================================
    pub fn gegl_lookup_free(lookup: *mut GeglLookup);
    pub fn gegl_lookup_new(function: GeglLookupFunction, data: gpointer) -> *mut GeglLookup;
    pub fn gegl_lookup_new_full(function: GeglLookupFunction, data: gpointer, start: c_float, end: c_float, precision: c_float) -> *mut GeglLookup;

    //=========================================================================
    // GeglMatrix3
    //=========================================================================
    pub fn gegl_matrix3_get_type() -> GType;
    pub fn gegl_matrix3_new() -> *mut GeglMatrix3;
    pub fn gegl_matrix3_copy(matrix: *const GeglMatrix3) -> *mut GeglMatrix3;
    pub fn gegl_matrix3_copy_into(dst: *mut GeglMatrix3, src: *const GeglMatrix3);
    pub fn gegl_matrix3_determinant(matrix: *const GeglMatrix3) -> c_double;
    pub fn gegl_matrix3_equal(matrix1: *const GeglMatrix3, matrix2: *const GeglMatrix3) -> gboolean;
    pub fn gegl_matrix3_identity(matrix: *mut GeglMatrix3);
    pub fn gegl_matrix3_invert(matrix: *mut GeglMatrix3);
    pub fn gegl_matrix3_is_affine(matrix: *const GeglMatrix3) -> gboolean;
    pub fn gegl_matrix3_is_identity(matrix: *const GeglMatrix3) -> gboolean;
    pub fn gegl_matrix3_is_scale(matrix: *const GeglMatrix3) -> gboolean;
    pub fn gegl_matrix3_is_translate(matrix: *const GeglMatrix3) -> gboolean;
    pub fn gegl_matrix3_multiply(left: *const GeglMatrix3, right: *const GeglMatrix3, product: *mut GeglMatrix3);
    pub fn gegl_matrix3_originate(matrix: *mut GeglMatrix3, x: c_double, y: c_double);
    pub fn gegl_matrix3_parse_string(matrix: *mut GeglMatrix3, string: *const c_char);
    pub fn gegl_matrix3_round_error(matrix: *mut GeglMatrix3);
    pub fn gegl_matrix3_to_string(matrix: *const GeglMatrix3) -> *mut c_char;
    pub fn gegl_matrix3_transform_point(matrix: *const GeglMatrix3, x: *mut c_double, y: *mut c_double);

    //=========================================================================
    // GeglParamSpecDouble
    //=========================================================================
    pub fn gegl_param_spec_double_set_digits(pspec: *mut GeglParamSpecDouble, digits: c_int);
    pub fn gegl_param_spec_double_set_steps(pspec: *mut GeglParamSpecDouble, small_step: c_double, big_step: c_double);

    //=========================================================================
    // GeglParamSpecEnum
    //=========================================================================
    pub fn gegl_param_spec_enum_exclude_value(espec: *mut GeglParamSpecEnum, value: c_int);

    //=========================================================================
    // GeglParamSpecInt
    //=========================================================================
    pub fn gegl_param_spec_int_set_steps(pspec: *mut GeglParamSpecInt, small_step: c_int, big_step: c_int);

    //=========================================================================
    // GeglPathList
    //=========================================================================
    pub fn gegl_path_list_append(head: *mut GeglPathList, ...) -> *mut GeglPathList;
    pub fn gegl_path_list_destroy(path: *mut GeglPathList) -> *mut GeglPathList;

    //=========================================================================
    // GeglPathPoint
    //=========================================================================
    pub fn gegl_path_point_dist(a: *mut GeglPathPoint, b: *mut GeglPathPoint) -> c_double;
    pub fn gegl_path_point_lerp(dest: *mut GeglPathPoint, a: *mut GeglPathPoint, b: *mut GeglPathPoint, t: c_float);

    //=========================================================================
    // GeglRandom
    //=========================================================================
    pub fn gegl_random_get_type() -> GType;
    pub fn gegl_random_new() -> *mut GeglRandom;
    pub fn gegl_random_new_with_seed(seed: u32) -> *mut GeglRandom;
    pub fn gegl_random_duplicate(rand: *mut GeglRandom) -> *mut GeglRandom;
    pub fn gegl_random_float(rand: *const GeglRandom, x: c_int, y: c_int, z: c_int, n: c_int) -> c_float;
    pub fn gegl_random_float_range(rand: *const GeglRandom, x: c_int, y: c_int, z: c_int, n: c_int, min: c_float, max: c_float) -> c_float;
    pub fn gegl_random_free(rand: *mut GeglRandom);
    pub fn gegl_random_int(rand: *const GeglRandom, x: c_int, y: c_int, z: c_int, n: c_int) -> u32;
    pub fn gegl_random_int_range(rand: *const GeglRandom, x: c_int, y: c_int, z: c_int, n: c_int, min: c_int, max: c_int) -> i32;
    pub fn gegl_random_set_seed(rand: *mut GeglRandom, seed: u32);

    //=========================================================================
    // GeglRectangle
    //=========================================================================
    pub fn gegl_rectangle_get_type() -> GType;
    pub fn gegl_rectangle_new(x: c_int, y: c_int, width: c_uint, height: c_uint) -> *mut GeglRectangle;
    pub fn gegl_rectangle_align(destination: *mut GeglRectangle, rectangle: *const GeglRectangle, tile: *const GeglRectangle, alignment: GeglRectangleAlignment) -> gboolean;
    pub fn gegl_rectangle_align_to_buffer(destination: *mut GeglRectangle, rectangle: *const GeglRectangle, buffer: *mut GeglBuffer, alignment: GeglRectangleAlignment) -> gboolean;
    pub fn gegl_rectangle_bounding_box(destination: *mut GeglRectangle, source1: *const GeglRectangle, source2: *const GeglRectangle);
    pub fn gegl_rectangle_contains(parent: *const GeglRectangle, child: *const GeglRectangle) -> gboolean;
    pub fn gegl_rectangle_copy(destination: *mut GeglRectangle, source: *const GeglRectangle);
    pub fn gegl_rectangle_dump(rectangle: *const GeglRectangle);
    pub fn gegl_rectangle_dup(rectangle: *const GeglRectangle) -> *mut GeglRectangle;
    pub fn gegl_rectangle_equal(rectangle1: *const GeglRectangle, rectangle2: *const GeglRectangle) -> gboolean;
    pub fn gegl_rectangle_equal_coords(rectangle: *const GeglRectangle, x: c_int, y: c_int, width: c_int, height: c_int) -> gboolean;
    pub fn gegl_rectangle_intersect(dest: *mut GeglRectangle, src1: *const GeglRectangle, src2: *const GeglRectangle) -> gboolean;
    pub fn gegl_rectangle_is_empty(rectangle: *const GeglRectangle) -> gboolean;
    pub fn gegl_rectangle_is_infinite_plane(rectangle: *const GeglRectangle) -> gboolean;
    pub fn gegl_rectangle_set(rectangle: *mut GeglRectangle, x: c_int, y: c_int, width: c_uint, height: c_uint);
    pub fn gegl_rectangle_subtract(destination: *mut GeglRectangle, minuend: *const GeglRectangle, subtrahend: *const GeglRectangle) -> c_int;
    pub fn gegl_rectangle_subtract_bounding_box(destination: *mut GeglRectangle, minuend: *const GeglRectangle, subtrahend: *const GeglRectangle) -> gboolean;
    pub fn gegl_rectangle_xor(destination: *mut GeglRectangle, source1: *const GeglRectangle, source2: *const GeglRectangle) -> c_int;
    pub fn gegl_rectangle_infinite_plane() -> GeglRectangle;

    //=========================================================================
    // GeglSampler
    //=========================================================================
    pub fn gegl_sampler_get(sampler: *mut GeglSampler, x: c_double, y: c_double, scale: *mut GeglBufferMatrix2, output: *mut c_void, repeat_mode: GeglAbyssPolicy);
    pub fn gegl_sampler_get_context_rect(sampler: *mut GeglSampler) -> *const GeglRectangle;
    pub fn gegl_sampler_get_fun(sampler: *mut GeglSampler) -> GeglSamplerGetFun;

    //=========================================================================
    // GeglAudioFragment
    //=========================================================================
    pub fn gegl_audio_fragment_get_type() -> GType;
    pub fn gegl_audio_fragment_new(sample_rate: c_int, channels: c_int, channel_layout: c_int, max_samples: c_int) -> *mut GeglAudioFragment;
    pub fn gegl_audio_fragment_get_channel_layout(audio: *mut GeglAudioFragment) -> c_int;
    pub fn gegl_audio_fragment_get_channels(audio: *mut GeglAudioFragment) -> c_int;
    pub fn gegl_audio_fragment_get_max_samples(audio: *mut GeglAudioFragment) -> c_int;
    pub fn gegl_audio_fragment_get_pos(audio: *mut GeglAudioFragment) -> c_int;
    pub fn gegl_audio_fragment_get_sample_count(audio: *mut GeglAudioFragment) -> c_int;
    pub fn gegl_audio_fragment_get_sample_rate(audio: *mut GeglAudioFragment) -> c_int;
    pub fn gegl_audio_fragment_set_channel_layout(audio: *mut GeglAudioFragment, channel_layout: c_int);
    pub fn gegl_audio_fragment_set_channels(audio: *mut GeglAudioFragment, channels: c_int);
    pub fn gegl_audio_fragment_set_max_samples(audio: *mut GeglAudioFragment, max_samples: c_int);
    pub fn gegl_audio_fragment_set_pos(audio: *mut GeglAudioFragment, pos: c_int);
    pub fn gegl_audio_fragment_set_sample_count(audio: *mut GeglAudioFragment, sample_count: c_int);
    pub fn gegl_audio_fragment_set_sample_rate(audio: *mut GeglAudioFragment, sample_rate: c_int);

    //=========================================================================
    // GeglBuffer
    //=========================================================================
    pub fn gegl_buffer_get_type() -> GType;
    pub fn gegl_buffer_introspectable_new(format_name: *const c_char, x: c_int, y: c_int, width: c_int, height: c_int) -> *mut GeglBuffer;
    pub fn gegl_buffer_linear_new(extent: *const GeglRectangle, format: *const babl::Babl) -> *mut GeglBuffer;
    pub fn gegl_buffer_linear_new_from_data(data: gpointer, format: *const babl::Babl, extent: *const GeglRectangle, rowstride: c_int, destroy_fn: glib::GDestroyNotify, destroy_fn_data: gpointer) -> *mut GeglBuffer;
    pub fn gegl_buffer_new(extent: *const GeglRectangle, format: *const babl::Babl) -> *mut GeglBuffer;
    pub fn gegl_buffer_new_for_backend(extent: *const GeglRectangle, backend: *mut GeglTileBackend) -> *mut GeglBuffer;
    pub fn gegl_buffer_load(path: *const c_char) -> *mut GeglBuffer;
    pub fn gegl_buffer_open(path: *const c_char) -> *mut GeglBuffer;
    pub fn gegl_buffer_swap_create_file(suffix: *const c_char) -> *mut c_char;
    pub fn gegl_buffer_swap_has_file(path: *const c_char) -> gboolean;
    pub fn gegl_buffer_swap_remove_file(path: *const c_char);
    pub fn gegl_buffer_add_handler(buffer: *mut GeglBuffer, handler: gpointer);
    pub fn gegl_buffer_clear(buffer: *mut GeglBuffer, roi: *const GeglRectangle);
    pub fn gegl_buffer_copy(src: *mut GeglBuffer, src_rect: *const GeglRectangle, repeat_mode: GeglAbyssPolicy, dst: *mut GeglBuffer, dst_rect: *const GeglRectangle);
    pub fn gegl_buffer_create_sub_buffer(buffer: *mut GeglBuffer, extent: *const GeglRectangle) -> *mut GeglBuffer;
    pub fn gegl_buffer_dup(buffer: *mut GeglBuffer) -> *mut GeglBuffer;
    pub fn gegl_buffer_flush(buffer: *mut GeglBuffer);
    pub fn gegl_buffer_flush_ext(buffer: *mut GeglBuffer, rect: *const GeglRectangle);
    pub fn gegl_buffer_freeze_changed(buffer: *mut GeglBuffer);
    pub fn gegl_buffer_get(buffer: *mut GeglBuffer, rect: *const GeglRectangle, scale: c_double, format: *const babl::Babl, dest: gpointer, rowstride: c_int, repeat_mode: GeglAbyssPolicy);
    pub fn gegl_buffer_get_abyss(buffer: *mut GeglBuffer) -> *const GeglRectangle;
    pub fn gegl_buffer_get_extent(buffer: *mut GeglBuffer) -> *const GeglRectangle;
    pub fn gegl_buffer_get_format(buffer: *mut GeglBuffer) -> *const babl::Babl;
    pub fn gegl_buffer_get_tile(buffer: *mut GeglBuffer, x: c_int, y: c_int, z: c_int) -> *mut GeglTile;
    pub fn gegl_buffer_introspectable_get(buffer: *mut GeglBuffer, rect: *const GeglRectangle, scale: c_double, format_name: *const c_char, repeat_mode: GeglAbyssPolicy, data_length: *mut c_uint) -> *mut u8;
    pub fn gegl_buffer_introspectable_set(buffer: *mut GeglBuffer, rect: *const GeglRectangle, format_name: *const c_char, src: *const u8, src_length: c_int);
    pub fn gegl_buffer_iterator_new(buffer: *mut GeglBuffer, roi: *const GeglRectangle, level: c_int, format: *const babl::Babl, access_mode: GeglAccessMode, abyss_policy: GeglAbyssPolicy, max_slots: c_int) -> *mut GeglBufferIterator;
    pub fn gegl_buffer_linear_close(buffer: *mut GeglBuffer, linear: gpointer);
    pub fn gegl_buffer_linear_open(buffer: *mut GeglBuffer, extent: *const GeglRectangle, rowstride: *mut c_int, format: *const babl::Babl) -> gpointer;
    pub fn gegl_buffer_remove_handler(buffer: *mut GeglBuffer, handler: gpointer);
    pub fn gegl_buffer_sample(buffer: *mut GeglBuffer, x: c_double, y: c_double, scale: *mut GeglBufferMatrix2, dest: gpointer, format: *const babl::Babl, sampler_type: GeglSamplerType, repeat_mode: GeglAbyssPolicy);
    pub fn gegl_buffer_sample_at_level(buffer: *mut GeglBuffer, x: c_double, y: c_double, scale: *mut GeglBufferMatrix2, dest: gpointer, format: *const babl::Babl, level: c_int, sampler_type: GeglSamplerType, repeat_mode: GeglAbyssPolicy);
    pub fn gegl_buffer_sample_cleanup(buffer: *mut GeglBuffer);
    pub fn gegl_buffer_sampler_new(buffer: *mut GeglBuffer, format: *const babl::Babl, sampler_type: GeglSamplerType) -> *mut GeglSampler;
    pub fn gegl_buffer_sampler_new_at_level(buffer: *mut GeglBuffer, format: *const babl::Babl, sampler_type: GeglSamplerType, level: c_int) -> *mut GeglSampler;
    pub fn gegl_buffer_save(buffer: *mut GeglBuffer, path: *const c_char, roi: *const GeglRectangle);
    pub fn gegl_buffer_set(buffer: *mut GeglBuffer, rect: *const GeglRectangle, mipmap_level: c_int, format: *const babl::Babl, src: *mut c_void, rowstride: c_int);
    pub fn gegl_buffer_set_abyss(buffer: *mut GeglBuffer, abyss: *const GeglRectangle) -> gboolean;
    pub fn gegl_buffer_set_color(buffer: *mut GeglBuffer, rect: *const GeglRectangle, color: *mut GeglColor);
    pub fn gegl_buffer_set_color_from_pixel(buffer: *mut GeglBuffer, rect: *const GeglRectangle, pixel: gconstpointer, pixel_format: *const babl::Babl);
    pub fn gegl_buffer_set_extent(buffer: *mut GeglBuffer, extent: *const GeglRectangle) -> gboolean;
    pub fn gegl_buffer_set_format(buffer: *mut GeglBuffer, format: *const babl::Babl) -> *const babl::Babl;
    pub fn gegl_buffer_set_pattern(buffer: *mut GeglBuffer, rect: *const GeglRectangle, pattern: *mut GeglBuffer, x_offset: c_int, y_offset: c_int);
    pub fn gegl_buffer_share_storage(buffer1: *mut GeglBuffer, buffer2: *mut GeglBuffer) -> gboolean;
    pub fn gegl_buffer_signal_connect(buffer: *mut GeglBuffer, detailed_signal: *const c_char, c_handler: gobject::GCallback, data: gpointer) -> c_long;
    pub fn gegl_buffer_thaw_changed(buffer: *mut GeglBuffer);

    //=========================================================================
    // GeglColor
    //=========================================================================
    pub fn gegl_color_get_type() -> GType;
    pub fn gegl_color_new(string: *const c_char) -> *mut GeglColor;
    pub fn gegl_color_duplicate(color: *mut GeglColor) -> *mut GeglColor;
    pub fn gegl_color_get_components(color: *mut GeglColor, format: *mut gobject::GValue, components_length: *mut c_int) -> *mut c_double;
    pub fn gegl_color_get_format(color: *mut GeglColor) -> *const babl::Babl;
    pub fn gegl_color_get_pixel(color: *mut GeglColor, format: *const babl::Babl, pixel: *mut c_void);
    pub fn gegl_color_get_rgba(color: *mut GeglColor, red: *mut c_double, green: *mut c_double, blue: *mut c_double, alpha: *mut c_double);
    pub fn gegl_color_set_components(color: *mut GeglColor, format: *mut gobject::GValue, components: *mut c_double, components_length: c_int);
    pub fn gegl_color_set_pixel(color: *mut GeglColor, format: *const babl::Babl, pixel: *mut c_void);
    pub fn gegl_color_set_rgba(color: *mut GeglColor, red: c_double, green: c_double, blue: c_double, alpha: c_double);

    //=========================================================================
    // GeglConfig
    //=========================================================================
    pub fn gegl_config_get_type() -> GType;

    //=========================================================================
    // GeglCurve
    //=========================================================================
    pub fn gegl_curve_get_type() -> GType;
    pub fn gegl_curve_new(y_min: c_double, y_max: c_double) -> *mut GeglCurve;
    pub fn gegl_curve_new_default() -> *mut GeglCurve;
    pub fn gegl_curve_add_point(curve: *mut GeglCurve, x: c_double, y: c_double) -> c_uint;
    pub fn gegl_curve_calc_value(curve: *mut GeglCurve, x: c_double) -> c_double;
    pub fn gegl_curve_calc_values(curve: *mut GeglCurve, x_min: c_double, x_max: c_double, num_samples: c_uint, xs: *mut c_double, ys: *mut c_double);
    pub fn gegl_curve_duplicate(curve: *mut GeglCurve) -> *mut GeglCurve;
    pub fn gegl_curve_get_point(curve: *mut GeglCurve, index: c_uint, x: *mut c_double, y: *mut c_double);
    pub fn gegl_curve_get_y_bounds(curve: *mut GeglCurve, min_y: *mut c_double, max_y: *mut c_double);
    pub fn gegl_curve_num_points(curve: *mut GeglCurve) -> c_uint;
    pub fn gegl_curve_set_point(curve: *mut GeglCurve, index: c_uint, x: c_double, y: c_double);

    //=========================================================================
    // GeglMetadataHash
    //=========================================================================
    pub fn gegl_metadata_hash_get_type() -> GType;
    pub fn gegl_metadata_hash_new() -> *mut GeglMetadataStore;

    //=========================================================================
    // GeglMetadataStore
    //=========================================================================
    pub fn gegl_metadata_store_get_type() -> GType;
    pub fn gegl_metadata_store_declare(self_: *mut GeglMetadataStore, pspec: *mut gobject::GParamSpec);
    pub fn gegl_metadata_store_get_artist(self_: *mut GeglMetadataStore) -> *const c_char;
    pub fn gegl_metadata_store_get_comment(self_: *mut GeglMetadataStore) -> *const c_char;
    pub fn gegl_metadata_store_get_copyright(self_: *mut GeglMetadataStore) -> *const c_char;
    pub fn gegl_metadata_store_get_description(self_: *mut GeglMetadataStore) -> *const c_char;
    pub fn gegl_metadata_store_get_disclaimer(self_: *mut GeglMetadataStore) -> *const c_char;
    pub fn gegl_metadata_store_get_file_module_name(self_: *mut GeglMetadataStore) -> *const c_char;
    pub fn gegl_metadata_store_get_resolution_unit(self_: *mut GeglMetadataStore) -> GeglResolutionUnit;
    pub fn gegl_metadata_store_get_resolution_x(self_: *mut GeglMetadataStore) -> c_double;
    pub fn gegl_metadata_store_get_resolution_y(self_: *mut GeglMetadataStore) -> c_double;
    pub fn gegl_metadata_store_get_software(self_: *mut GeglMetadataStore) -> *const c_char;
    pub fn gegl_metadata_store_get_source(self_: *mut GeglMetadataStore) -> *const c_char;
    pub fn gegl_metadata_store_get_string(self_: *mut GeglMetadataStore, name: *const c_char) -> *const c_char;
    pub fn gegl_metadata_store_get_timestamp(self_: *mut GeglMetadataStore) -> *mut glib::GDateTime;
    pub fn gegl_metadata_store_get_title(self_: *mut GeglMetadataStore) -> *const c_char;
    pub fn gegl_metadata_store_get_value(self_: *mut GeglMetadataStore, name: *const c_char, value: *mut gobject::GValue);
    pub fn gegl_metadata_store_get_warning(self_: *mut GeglMetadataStore) -> *const c_char;
    pub fn gegl_metadata_store_has_value(self_: *mut GeglMetadataStore, name: *const c_char) -> gboolean;
    pub fn gegl_metadata_store_notify(self_: *mut GeglMetadataStore, pspec: *mut gobject::GParamSpec, shadow: gboolean);
    pub fn gegl_metadata_store_register(self_: *mut GeglMetadataStore, local_name: *const c_char, name: *const c_char, transform: gobject::GValueTransform);
    pub fn gegl_metadata_store_set_artist(self_: *mut GeglMetadataStore, artist: *const c_char);
    pub fn gegl_metadata_store_set_comment(self_: *mut GeglMetadataStore, comment: *const c_char);
    pub fn gegl_metadata_store_set_copyright(self_: *mut GeglMetadataStore, copyright: *const c_char);
    pub fn gegl_metadata_store_set_description(self_: *mut GeglMetadataStore, description: *const c_char);
    pub fn gegl_metadata_store_set_disclaimer(self_: *mut GeglMetadataStore, disclaimer: *const c_char);
    pub fn gegl_metadata_store_set_resolution_unit(self_: *mut GeglMetadataStore, unit: GeglResolutionUnit);
    pub fn gegl_metadata_store_set_resolution_x(self_: *mut GeglMetadataStore, resolution_x: c_double);
    pub fn gegl_metadata_store_set_resolution_y(self_: *mut GeglMetadataStore, resolution_y: c_double);
    pub fn gegl_metadata_store_set_software(self_: *mut GeglMetadataStore, software: *const c_char);
    pub fn gegl_metadata_store_set_source(self_: *mut GeglMetadataStore, source: *const c_char);
    pub fn gegl_metadata_store_set_string(self_: *mut GeglMetadataStore, name: *const c_char, string: *const c_char);
    pub fn gegl_metadata_store_set_timestamp(self_: *mut GeglMetadataStore, timestamp: *const glib::GDateTime);
    pub fn gegl_metadata_store_set_title(self_: *mut GeglMetadataStore, title: *const c_char);
    pub fn gegl_metadata_store_set_value(self_: *mut GeglMetadataStore, name: *const c_char, value: *const gobject::GValue);
    pub fn gegl_metadata_store_set_warning(self_: *mut GeglMetadataStore, warning: *const c_char);
    pub fn gegl_metadata_store_typeof_value(self_: *mut GeglMetadataStore, name: *const c_char) -> GType;

    //=========================================================================
    // GeglNode
    //=========================================================================
    pub fn gegl_node_get_type() -> GType;
    pub fn gegl_node_new() -> *mut GeglNode;
    pub fn gegl_node_new_from_file(path: *const c_char) -> *mut GeglNode;
    pub fn gegl_node_new_from_serialized(chaindata: *const c_char, path_root: *const c_char) -> *mut GeglNode;
    pub fn gegl_node_new_from_xml(xmldata: *const c_char, path_root: *const c_char) -> *mut GeglNode;
    pub fn gegl_node_add_child(graph: *mut GeglNode, child: *mut GeglNode) -> *mut GeglNode;
    pub fn gegl_node_blit(node: *mut GeglNode, scale: c_double, roi: *const GeglRectangle, format: *const babl::Babl, destination_buf: gpointer, rowstride: c_int, flags: GeglBlitFlags);
    pub fn gegl_node_blit_buffer(node: *mut GeglNode, buffer: *mut GeglBuffer, roi: *const GeglRectangle, level: c_int, abyss_policy: GeglAbyssPolicy);
    pub fn gegl_node_connect(a: *mut GeglNode, a_pad_name: *const c_char, b: *mut GeglNode, b_pad_name: *const c_char) -> gboolean;
    pub fn gegl_node_connect_from(sink: *mut GeglNode, input_pad_name: *const c_char, source: *mut GeglNode, output_pad_name: *const c_char) -> gboolean;
    pub fn gegl_node_connect_to(source: *mut GeglNode, output_pad_name: *const c_char, sink: *mut GeglNode, input_pad_name: *const c_char) -> gboolean;
    pub fn gegl_node_create_child(parent: *mut GeglNode, operation: *const c_char) -> *mut GeglNode;
    pub fn gegl_node_detect(node: *mut GeglNode, x: c_int, y: c_int) -> *mut GeglNode;
    pub fn gegl_node_disconnect(node: *mut GeglNode, input_pad: *const c_char) -> gboolean;
    pub fn gegl_node_find_property(node: *mut GeglNode, property_name: *const c_char) -> *mut gobject::GParamSpec;
    pub fn gegl_node_get(node: *mut GeglNode, first_property_name: *const c_char, ...);
    pub fn gegl_node_get_bounding_box(node: *mut GeglNode) -> GeglRectangle;
    pub fn gegl_node_get_children(node: *mut GeglNode) -> *mut glib::GSList;
    pub fn gegl_node_get_consumers(node: *mut GeglNode, output_pad: *const c_char, nodes: *mut *mut *mut GeglNode, pads: *mut *mut *const c_char) -> c_int;
    pub fn gegl_node_get_gegl_operation(node: *mut GeglNode) -> *mut GeglOperation;
    pub fn gegl_node_get_input_proxy(node: *mut GeglNode, pad_name: *const c_char) -> *mut GeglNode;
    pub fn gegl_node_get_operation(node: *const GeglNode) -> *const c_char;
    pub fn gegl_node_get_output_proxy(node: *mut GeglNode, pad_name: *const c_char) -> *mut GeglNode;
    pub fn gegl_node_get_parent(node: *mut GeglNode) -> *mut GeglNode;
    pub fn gegl_node_get_passthrough(node: *mut GeglNode) -> gboolean;
    pub fn gegl_node_get_producer(node: *mut GeglNode, input_pad_name: *const c_char, output_pad_name: *mut *mut c_char) -> *mut GeglNode;
    pub fn gegl_node_get_property(node: *mut GeglNode, property_name: *const c_char, value: *mut gobject::GValue);
    //pub fn gegl_node_get_valist(node: *mut GeglNode, first_property_name: *const c_char, args: /*Unimplemented*/va_list);
    pub fn gegl_node_has_pad(node: *mut GeglNode, pad_name: *const c_char) -> gboolean;
    pub fn gegl_node_introspectable_get_bounding_box(node: *mut GeglNode) -> *mut GeglRectangle;
    pub fn gegl_node_introspectable_get_property(node: *mut GeglNode, property_name: *const c_char) -> *mut gobject::GValue;
    pub fn gegl_node_is_graph(node: *mut GeglNode) -> gboolean;
    pub fn gegl_node_link(source: *mut GeglNode, sink: *mut GeglNode);
    pub fn gegl_node_link_many(source: *mut GeglNode, first_sink: *mut GeglNode, ...);
    pub fn gegl_node_list_input_pads(node: *mut GeglNode) -> *mut *mut c_char;
    pub fn gegl_node_list_output_pads(node: *mut GeglNode) -> *mut *mut c_char;
    pub fn gegl_node_new_child(parent: *mut GeglNode, first_property_name: *const c_char, ...) -> *mut GeglNode;
    pub fn gegl_node_new_processor(node: *mut GeglNode, rectangle: *const GeglRectangle) -> *mut GeglProcessor;
    pub fn gegl_node_process(sink_node: *mut GeglNode);
    pub fn gegl_node_progress(node: *mut GeglNode, progress: c_double, message: *mut c_char);
    pub fn gegl_node_remove_child(graph: *mut GeglNode, child: *mut GeglNode) -> *mut GeglNode;
    pub fn gegl_node_set(node: *mut GeglNode, first_property_name: *const c_char, ...);
    pub fn gegl_node_set_enum_as_string(node: *mut GeglNode, key: *const c_char, value: *const c_char);
    pub fn gegl_node_set_passthrough(node: *mut GeglNode, passthrough: gboolean);
    pub fn gegl_node_set_property(node: *mut GeglNode, property_name: *const c_char, value: *const gobject::GValue);
    pub fn gegl_node_set_time(node: *mut GeglNode, time: c_double);
    //pub fn gegl_node_set_valist(node: *mut GeglNode, first_property_name: *const c_char, args: /*Unimplemented*/va_list);
    pub fn gegl_node_to_xml(node: *mut GeglNode, path_root: *const c_char) -> *mut c_char;
    pub fn gegl_node_to_xml_full(head: *mut GeglNode, tail: *mut GeglNode, path_root: *const c_char) -> *mut c_char;

    //=========================================================================
    // GeglOperation
    //=========================================================================
    pub fn gegl_operation_get_type() -> GType;
    pub fn gegl_operation_find_property(operation_type: *const c_char, property_name: *const c_char) -> *mut gobject::GParamSpec;
    pub fn gegl_operation_get_key(operation_type: *const c_char, key_name: *const c_char) -> *const c_char;
    pub fn gegl_operation_get_op_version(op_name: *const c_char) -> *const c_char;
    pub fn gegl_operation_get_property_key(operation_type: *const c_char, property_name: *const c_char, property_key_name: *const c_char) -> *const c_char;
    pub fn gegl_operation_list_keys(operation_type: *const c_char, n_keys: *mut c_uint) -> *mut *mut c_char;
    pub fn gegl_operation_list_properties(operation_type: *const c_char, n_properties_p: *mut c_uint) -> *mut *mut gobject::GParamSpec;
    pub fn gegl_operation_list_property_keys(operation_type: *const c_char, property_name: *const c_char, n_keys: *mut c_uint) -> *mut *mut c_char;

    //=========================================================================
    // GeglParamAudioFragment
    //=========================================================================
    pub fn gegl_param_audio_fragment_get_type() -> GType;

    //=========================================================================
    // GeglParamColor
    //=========================================================================
    pub fn gegl_param_color_get_type() -> GType;

    //=========================================================================
    // GeglParamCurve
    //=========================================================================
    pub fn gegl_param_curve_get_type() -> GType;

    //=========================================================================
    // GeglParamDouble
    //=========================================================================
    pub fn gegl_param_double_get_type() -> GType;

    //=========================================================================
    // GeglParamEnum
    //=========================================================================
    pub fn gegl_param_enum_get_type() -> GType;

    //=========================================================================
    // GeglParamFilePath
    //=========================================================================
    pub fn gegl_param_file_path_get_type() -> GType;

    //=========================================================================
    // GeglParamFormat
    //=========================================================================
    pub fn gegl_param_format_get_type() -> GType;

    //=========================================================================
    // GeglParamInt
    //=========================================================================
    pub fn gegl_param_int_get_type() -> GType;

    //=========================================================================
    // GeglParamPath
    //=========================================================================
    pub fn gegl_param_path_get_type() -> GType;

    //=========================================================================
    // GeglParamSeed
    //=========================================================================
    pub fn gegl_param_seed_get_type() -> GType;

    //=========================================================================
    // GeglParamString
    //=========================================================================
    pub fn gegl_param_string_get_type() -> GType;

    //=========================================================================
    // GeglParamUri
    //=========================================================================
    pub fn gegl_param_uri_get_type() -> GType;

    //=========================================================================
    // GeglPath
    //=========================================================================
    pub fn gegl_path_get_type() -> GType;
    pub fn gegl_path_new() -> *mut GeglPath;
    pub fn gegl_path_new_from_string(instructions: *const c_char) -> *mut GeglPath;
    pub fn gegl_path_add_flattener(func: GeglFlattenerFunc);
    pub fn gegl_path_add_type(type_: c_char, items: c_int, description: *const c_char);
    pub fn gegl_path_append(path: *mut GeglPath, ...);
    pub fn gegl_path_calc(path: *mut GeglPath, pos: c_double, x: *mut c_double, y: *mut c_double) -> gboolean;
    pub fn gegl_path_calc_values(path: *mut GeglPath, num_samples: c_uint, xs: *mut c_double, ys: *mut c_double);
    pub fn gegl_path_calc_y_for_x(path: *mut GeglPath, x: c_double, y: *mut c_double) -> c_int;
    pub fn gegl_path_clear(path: *mut GeglPath);
    pub fn gegl_path_closest_point(path: *mut GeglPath, x: c_double, y: c_double, on_path_x: *mut c_double, on_path_y: *mut c_double, node_pos_before: *mut c_int) -> c_double;
    pub fn gegl_path_dirty(path: *mut GeglPath);
    pub fn gegl_path_foreach(path: *mut GeglPath, each_item: GeglNodeFunction, user_data: gpointer);
    pub fn gegl_path_foreach_flat(path: *mut GeglPath, each_item: GeglNodeFunction, user_data: gpointer);
    pub fn gegl_path_freeze(path: *mut GeglPath);
    pub fn gegl_path_get_bounds(self_: *mut GeglPath, min_x: *mut c_double, max_x: *mut c_double, min_y: *mut c_double, max_y: *mut c_double);
    pub fn gegl_path_get_flat_path(path: *mut GeglPath) -> *mut GeglPathList;
    pub fn gegl_path_get_length(path: *mut GeglPath) -> c_double;
    pub fn gegl_path_get_matrix(path: *mut GeglPath, matrix: *mut GeglMatrix3);
    pub fn gegl_path_get_n_nodes(path: *mut GeglPath) -> c_int;
    pub fn gegl_path_get_node(path: *mut GeglPath, index: c_int, node: *mut GeglPathItem) -> gboolean;
    pub fn gegl_path_get_path(path: *mut GeglPath) -> *mut GeglPathList;
    pub fn gegl_path_insert_node(path: *mut GeglPath, pos: c_int, node: *const GeglPathItem);
    pub fn gegl_path_is_empty(path: *mut GeglPath) -> gboolean;
    pub fn gegl_path_parse_string(path: *mut GeglPath, instructions: *const c_char);
    pub fn gegl_path_remove_node(path: *mut GeglPath, pos: c_int);
    pub fn gegl_path_replace_node(path: *mut GeglPath, pos: c_int, node: *const GeglPathItem);
    pub fn gegl_path_set_matrix(path: *mut GeglPath, matrix: *mut GeglMatrix3);
    pub fn gegl_path_thaw(path: *mut GeglPath);
    pub fn gegl_path_to_string(path: *mut GeglPath) -> *mut c_char;

    //=========================================================================
    // GeglProcessor
    //=========================================================================
    pub fn gegl_processor_get_type() -> GType;
    pub fn gegl_processor_get_buffer(processor: *mut GeglProcessor) -> *mut GeglBuffer;
    pub fn gegl_processor_set_level(processor: *mut GeglProcessor, level: c_int);
    pub fn gegl_processor_set_rectangle(processor: *mut GeglProcessor, rectangle: *const GeglRectangle);
    pub fn gegl_processor_set_scale(processor: *mut GeglProcessor, scale: c_double);
    pub fn gegl_processor_work(processor: *mut GeglProcessor, progress: *mut c_double) -> gboolean;

    //=========================================================================
    // GeglStats
    //=========================================================================
    pub fn gegl_stats_get_type() -> GType;

    //=========================================================================
    // GeglTileBackend
    //=========================================================================
    pub fn gegl_tile_backend_get_type() -> GType;
    pub fn gegl_tile_backend_unlink_swap(path: *mut c_char);
    pub fn gegl_tile_backend_command(backend: *mut GeglTileBackend, command: GeglTileCommand, x: c_int, y: c_int, z: c_int, data: gpointer) -> gpointer;
    pub fn gegl_tile_backend_get_extent(tile_backend: *mut GeglTileBackend) -> GeglRectangle;
    pub fn gegl_tile_backend_get_flush_on_destroy(tile_backend: *mut GeglTileBackend) -> gboolean;
    pub fn gegl_tile_backend_get_format(tile_backend: *mut GeglTileBackend) -> *const babl::Babl;
    pub fn gegl_tile_backend_get_tile_height(tile_backend: *mut GeglTileBackend) -> c_int;
    pub fn gegl_tile_backend_get_tile_size(tile_backend: *mut GeglTileBackend) -> c_int;
    pub fn gegl_tile_backend_get_tile_width(tile_backend: *mut GeglTileBackend) -> c_int;
    pub fn gegl_tile_backend_peek_storage(tile_backend: *mut GeglTileBackend) -> *mut GeglTileSource;
    pub fn gegl_tile_backend_set_extent(tile_backend: *mut GeglTileBackend, rectangle: *const GeglRectangle);
    pub fn gegl_tile_backend_set_flush_on_destroy(tile_backend: *mut GeglTileBackend, flush_on_destroy: gboolean);

    //=========================================================================
    // GeglTileHandler
    //=========================================================================
    pub fn gegl_tile_handler_get_type() -> GType;
    pub fn gegl_tile_handler_create_tile(handler: *mut GeglTileHandler, x: c_int, y: c_int, z: c_int) -> *mut GeglTile;
    pub fn gegl_tile_handler_damage_rect(handler: *mut GeglTileHandler, rect: *const GeglRectangle);
    pub fn gegl_tile_handler_damage_tile(handler: *mut GeglTileHandler, x: c_int, y: c_int, z: c_int, damage: u64);
    pub fn gegl_tile_handler_dup_tile(handler: *mut GeglTileHandler, tile: *mut GeglTile, x: c_int, y: c_int, z: c_int) -> *mut GeglTile;
    pub fn gegl_tile_handler_get_source_tile(handler: *mut GeglTileHandler, x: c_int, y: c_int, z: c_int, preserve_data: gboolean) -> *mut GeglTile;
    pub fn gegl_tile_handler_get_tile(handler: *mut GeglTileHandler, x: c_int, y: c_int, z: c_int, preserve_data: gboolean) -> *mut GeglTile;
    pub fn gegl_tile_handler_lock(handler: *mut GeglTileHandler);
    pub fn gegl_tile_handler_set_source(handler: *mut GeglTileHandler, source: *mut GeglTileSource);
    pub fn gegl_tile_handler_unlock(handler: *mut GeglTileHandler);

    //=========================================================================
    // GeglTileSource
    //=========================================================================
    pub fn gegl_tile_source_get_type() -> GType;

    //=========================================================================
    // GeglMetadata
    //=========================================================================
    pub fn gegl_metadata_get_type() -> GType;
    pub fn gegl_metadata_get_resolution(metadata: *mut GeglMetadata, unit: *mut GeglResolutionUnit, x: *mut c_float, y: *mut c_float) -> gboolean;
    pub fn gegl_metadata_iter_get_value(metadata: *mut GeglMetadata, iter: *mut GeglMetadataIter, value: *mut gobject::GValue) -> gboolean;
    pub fn gegl_metadata_iter_init(metadata: *mut GeglMetadata, iter: *mut GeglMetadataIter);
    pub fn gegl_metadata_iter_lookup(metadata: *mut GeglMetadata, iter: *mut GeglMetadataIter, key: *const c_char) -> gboolean;
    pub fn gegl_metadata_iter_next(metadata: *mut GeglMetadata, iter: *mut GeglMetadataIter) -> *const c_char;
    pub fn gegl_metadata_iter_set_value(metadata: *mut GeglMetadata, iter: *mut GeglMetadataIter, value: *const gobject::GValue) -> gboolean;
    pub fn gegl_metadata_register_map(metadata: *mut GeglMetadata, file_module: *const c_char, flags: c_uint, map: *const GeglMetadataMap, n_map: size_t);
    pub fn gegl_metadata_set_resolution(metadata: *mut GeglMetadata, unit: GeglResolutionUnit, x: c_float, y: c_float) -> gboolean;
    pub fn gegl_metadata_unregister_map(metadata: *mut GeglMetadata);

    //=========================================================================
    // Other functions
    //=========================================================================
    pub fn gegl_apply_op(buffer: *mut GeglBuffer, operation_name: *const c_char, ...);
    //pub fn gegl_apply_op_valist(buffer: *mut GeglBuffer, operation_name: *const c_char, var_args: /*Unimplemented*/va_list);
    pub fn gegl_babl_variant(format: *const babl::Babl, variant: GeglBablVariant) -> *const babl::Babl;
    pub fn gegl_calloc(size: size_t, n_memb: c_int) -> gpointer;
    pub fn gegl_cl_disable();
    pub fn gegl_cl_init(error: *mut *mut glib::GError) -> gboolean;
    pub fn gegl_cl_is_accelerated() -> gboolean;
    pub fn gegl_config() -> *mut GeglConfig;
    pub fn gegl_create_chain(ops: *const c_char, op_start: *mut GeglNode, op_end: *mut GeglNode, time: c_double, rel_dim: c_int, path_root: *const c_char, error: *mut *mut glib::GError);
    pub fn gegl_create_chain_argv(ops: *mut *mut c_char, op_start: *mut GeglNode, op_end: *mut GeglNode, time: c_double, rel_dim: c_int, path_root: *const c_char, error: *mut *mut glib::GError);
    pub fn gegl_exit();
    pub fn gegl_filter_op(source_buffer: *mut GeglBuffer, operation_name: *const c_char, ...) -> *mut GeglBuffer;
    //pub fn gegl_filter_op_valist(source_buffer: *mut GeglBuffer, operation_name: *const c_char, var_args: /*Unimplemented*/va_list) -> *mut GeglBuffer;
    pub fn gegl_format(format_name: *const c_char) -> *mut gobject::GValue;
    pub fn gegl_format_get_name(format: *mut gobject::GValue) -> *const c_char;
    pub fn gegl_free(mem: gpointer);
    pub fn gegl_get_option_group() -> *mut glib::GOptionGroup;
    pub fn gegl_get_version(major: *mut c_int, minor: *mut c_int, micro: *mut c_int);
    pub fn gegl_graph_dump_outputs(node: *mut GeglNode);
    pub fn gegl_graph_dump_request(node: *mut GeglNode, roi: *const GeglRectangle);
    pub fn gegl_has_operation(operation_type: *const c_char) -> gboolean;
    pub fn gegl_init(argc: *mut c_int, argv: *mut *mut *mut c_char);
    pub fn gegl_is_main_thread() -> gboolean;
    pub fn gegl_list_operations(n_operations_p: *mut c_uint) -> *mut *mut c_char;
    pub fn gegl_load_module_directory(path: *const c_char);
    pub fn gegl_malloc(n_bytes: size_t) -> gpointer;
    pub fn gegl_memeq_zero(ptr: gconstpointer, size: size_t) -> gboolean;
    pub fn gegl_memset_pattern(dst_ptr: gpointer, src_ptr: gconstpointer, pattern_size: c_int, count: c_int);
    pub fn gegl_parallel_distribute(max_n: c_int, func: GeglParallelDistributeFunc, user_data: gpointer);
    pub fn gegl_parallel_distribute_area(area: *const GeglRectangle, thread_cost: c_double, split_strategy: GeglSplitStrategy, func: GeglParallelDistributeAreaFunc, user_data: gpointer);
    pub fn gegl_parallel_distribute_range(size: size_t, thread_cost: c_double, func: GeglParallelDistributeRangeFunc, user_data: gpointer);
    pub fn gegl_param_spec_audio_fragment(name: *const c_char, nick: *const c_char, blurb: *const c_char, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gegl_param_spec_color(name: *const c_char, nick: *const c_char, blurb: *const c_char, default_color: *mut GeglColor, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gegl_param_spec_color_from_string(name: *const c_char, nick: *const c_char, blurb: *const c_char, default_color_string: *const c_char, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gegl_param_spec_color_get_default(self_: *mut gobject::GParamSpec) -> *mut GeglColor;
    pub fn gegl_param_spec_curve(name: *const c_char, nick: *const c_char, blurb: *const c_char, default_curve: *mut GeglCurve, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gegl_param_spec_double(name: *const c_char, nick: *const c_char, blurb: *const c_char, minimum: c_double, maximum: c_double, default_value: c_double, ui_minimum: c_double, ui_maximum: c_double, ui_gamma: c_double, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gegl_param_spec_enum(name: *const c_char, nick: *const c_char, blurb: *const c_char, enum_type: GType, default_value: c_int, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gegl_param_spec_file_path(name: *const c_char, nick: *const c_char, blurb: *const c_char, no_validate: gboolean, null_ok: gboolean, default_value: *const c_char, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gegl_param_spec_format(name: *const c_char, nick: *const c_char, blurb: *const c_char, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gegl_param_spec_get_property_key(pspec: *mut gobject::GParamSpec, key_name: *const c_char) -> *const c_char;
    pub fn gegl_param_spec_int(name: *const c_char, nick: *const c_char, blurb: *const c_char, minimum: c_int, maximum: c_int, default_value: c_int, ui_minimum: c_int, ui_maximum: c_int, ui_gamma: c_double, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gegl_param_spec_path(name: *const c_char, nick: *const c_char, blurb: *const c_char, default_path: *mut GeglPath, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gegl_param_spec_seed(name: *const c_char, nick: *const c_char, blurb: *const c_char, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gegl_param_spec_set_property_key(pspec: *mut gobject::GParamSpec, key_name: *const c_char, value: *const c_char);
    pub fn gegl_param_spec_string(name: *const c_char, nick: *const c_char, blurb: *const c_char, no_validate: gboolean, null_ok: gboolean, default_value: *const c_char, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gegl_param_spec_uri(name: *const c_char, nick: *const c_char, blurb: *const c_char, no_validate: gboolean, null_ok: gboolean, default_value: *const c_char, flags: gobject::GParamFlags) -> *mut gobject::GParamSpec;
    pub fn gegl_render_op(source_buffer: *mut GeglBuffer, target_buffer: *mut GeglBuffer, operation_name: *const c_char, ...);
    //pub fn gegl_render_op_valist(source_buffer: *mut GeglBuffer, target_buffer: *mut GeglBuffer, operation_name: *const c_char, var_args: /*Unimplemented*/va_list);
    pub fn gegl_reset_stats();
    pub fn gegl_scratch_alloc(size: size_t) -> gpointer;
    pub fn gegl_scratch_alloc0(size: size_t) -> gpointer;
    pub fn gegl_scratch_free(ptr: gpointer);
    pub fn gegl_serialize(start: *mut GeglNode, end: *mut GeglNode, basepath: *const c_char, serialize_flags: GeglSerializeFlag) -> *mut c_char;
    pub fn gegl_stats() -> *mut GeglStats;
    pub fn gegl_try_malloc(n_bytes: size_t) -> gpointer;

}
