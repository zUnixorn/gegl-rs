// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use crate::{ffi};
use glib::{translate::*};

glib::wrapper! {
    #[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
    pub struct Random(Boxed<ffi::GeglRandom>);

    match fn {
        copy => |ptr| glib::gobject_ffi::g_boxed_copy(ffi::gegl_random_get_type(), ptr as *mut _) as *mut ffi::GeglRandom,
        free => |ptr| glib::gobject_ffi::g_boxed_free(ffi::gegl_random_get_type(), ptr as *mut _),
        type_ => || ffi::gegl_random_get_type(),
    }
}

impl Random {
    /// Creates a new random number generator initialized with a random seed.
    /// This structure needs to be freed by the user with `gegl_random_free()`;
    #[doc(alias = "gegl_random_new")]
    pub fn new() -> Random {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::gegl_random_new())
        }
    }

    /// Return an opaque structure associated to the seed.
    /// This structure needs to be freed by the user with `gegl_random_free()`;
    /// ## `seed`
    /// an integer seed, change for different permutation.
    #[doc(alias = "gegl_random_new_with_seed")]
    #[doc(alias = "new_with_seed")]
    pub fn with_seed(seed: u32) -> Random {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::gegl_random_new_with_seed(seed))
        }
    }

    /// Return a new copy of an existing GeglRandom
    #[doc(alias = "gegl_random_duplicate")]
#[must_use]
    pub fn duplicate(&mut self) -> Option<Random> {
        unsafe {
            from_glib_full(ffi::gegl_random_duplicate(self.to_glib_none_mut().0))
        }
    }

    /// Return a random floating point number in range 0.0 .. 1.0.
    /// ## `x`
    /// x coordinate
    /// ## `y`
    /// y coordinate
    /// ## `z`
    /// z coordinate (mipmap level)
    /// ## `n`
    /// number no (each x,y coordinate provides its own sequence of
    /// numbers
    #[doc(alias = "gegl_random_float")]
    pub fn float(&self, x: i32, y: i32, z: i32, n: i32) -> f32 {
        unsafe {
            ffi::gegl_random_float(self.to_glib_none().0, x, y, z, n)
        }
    }

    /// Return a random floating point number in the range specified,
    /// for the given x,y coordinates and GeglRandom provided, if multiple different
    /// numbers are needed pass in incrementing n's.
    /// ## `x`
    /// x coordinate
    /// ## `y`
    /// y coordinate
    /// ## `z`
    /// z coordinate (mipmap level)
    /// ## `n`
    /// number no (each x,y coordinate provides its own sequence of
    /// numbers
    /// ## `min`
    /// minimum value
    /// ## `max`
    /// maximum value
    #[doc(alias = "gegl_random_float_range")]
    pub fn float_range(&self, x: i32, y: i32, z: i32, n: i32, min: f32, max: f32) -> f32 {
        unsafe {
            ffi::gegl_random_float_range(self.to_glib_none().0, x, y, z, n, min, max)
        }
    }

    /// Return a random integer number in range 0 .. MAX_UINT
    /// ## `x`
    /// x coordinate
    /// ## `y`
    /// y coordinate
    /// ## `z`
    /// z coordinate (mipmap level)
    /// ## `n`
    /// number no (each x,y coordinate provides its own sequence of
    /// numbers
    #[doc(alias = "gegl_random_int")]
    pub fn int(&self, x: i32, y: i32, z: i32, n: i32) -> u32 {
        unsafe {
            ffi::gegl_random_int(self.to_glib_none().0, x, y, z, n)
        }
    }

    /// Return a random integer point number in the range specified,
    /// for the given x,y coordinates and GeglRandom provided, if multiple different
    /// numbers are needed pass in incrementing n's.
    /// ## `x`
    /// x coordinate
    /// ## `y`
    /// y coordinate
    /// ## `z`
    /// z coordinate (mipmap level)
    /// ## `n`
    /// number no (each x,y coordinate provides its own sequence of
    /// numbers
    /// ## `min`
    /// minimum value
    /// ## `max`
    /// maximum value+1
    #[doc(alias = "gegl_random_int_range")]
    pub fn int_range(&self, x: i32, y: i32, z: i32, n: i32, min: i32, max: i32) -> i32 {
        unsafe {
            ffi::gegl_random_int_range(self.to_glib_none().0, x, y, z, n, min, max)
        }
    }

    /// Change the seed of an existing GeglRandom.
    /// ## `seed`
    /// an integer seed, change for different permutation.
    #[doc(alias = "gegl_random_set_seed")]
    pub fn set_seed(&mut self, seed: u32) {
        unsafe {
            ffi::gegl_random_set_seed(self.to_glib_none_mut().0, seed);
        }
    }
}

impl Default for Random {
                     fn default() -> Self {
                         Self::new()
                     }
                 }
