// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use crate::{ffi,Metadata,ResolutionUnit};
use glib::{prelude::*,signal::{connect_raw, SignalHandlerId},translate::*};
use std::{boxed::Box as Box_};

glib::wrapper! {
    #[doc(alias = "GeglMetadataStore")]
    pub struct MetadataStore(Object<ffi::GeglMetadataStore, ffi::GeglMetadataStoreClass>) @implements Metadata;

    match fn {
        type_ => || ffi::gegl_metadata_store_get_type(),
    }
}

impl MetadataStore {
        pub const NONE: Option<&'static MetadataStore> = None;
    
}

pub trait MetadataStoreExt: IsA<MetadataStore> + 'static {
    #[doc(alias = "gegl_metadata_store_get_artist")]
    #[doc(alias = "get_artist")]
    fn artist(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::gegl_metadata_store_get_artist(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gegl_metadata_store_get_comment")]
    #[doc(alias = "get_comment")]
    fn comment(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::gegl_metadata_store_get_comment(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gegl_metadata_store_get_copyright")]
    #[doc(alias = "get_copyright")]
    fn copyright(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::gegl_metadata_store_get_copyright(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gegl_metadata_store_get_description")]
    #[doc(alias = "get_description")]
    fn description(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::gegl_metadata_store_get_description(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gegl_metadata_store_get_disclaimer")]
    #[doc(alias = "get_disclaimer")]
    fn disclaimer(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::gegl_metadata_store_get_disclaimer(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gegl_metadata_store_get_file_module_name")]
    #[doc(alias = "get_file_module_name")]
    #[doc(alias = "file-module-name")]
    fn file_module_name(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::gegl_metadata_store_get_file_module_name(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gegl_metadata_store_get_resolution_unit")]
    #[doc(alias = "get_resolution_unit")]
    #[doc(alias = "resolution-unit")]
    fn resolution_unit(&self) -> ResolutionUnit {
        unsafe {
            from_glib(ffi::gegl_metadata_store_get_resolution_unit(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gegl_metadata_store_get_resolution_x")]
    #[doc(alias = "get_resolution_x")]
    #[doc(alias = "resolution-x")]
    fn resolution_x(&self) -> f64 {
        unsafe {
            ffi::gegl_metadata_store_get_resolution_x(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "gegl_metadata_store_get_resolution_y")]
    #[doc(alias = "get_resolution_y")]
    #[doc(alias = "resolution-y")]
    fn resolution_y(&self) -> f64 {
        unsafe {
            ffi::gegl_metadata_store_get_resolution_y(self.as_ref().to_glib_none().0)
        }
    }

    #[doc(alias = "gegl_metadata_store_get_software")]
    #[doc(alias = "get_software")]
    fn software(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::gegl_metadata_store_get_software(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gegl_metadata_store_get_source")]
    #[doc(alias = "get_source")]
    fn source(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::gegl_metadata_store_get_source(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gegl_metadata_store_get_string")]
    #[doc(alias = "get_string")]
    fn string(&self, name: &str) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::gegl_metadata_store_get_string(self.as_ref().to_glib_none().0, name.to_glib_none().0))
        }
    }

    #[doc(alias = "gegl_metadata_store_get_timestamp")]
    #[doc(alias = "get_timestamp")]
    fn timestamp(&self) -> Option<glib::DateTime> {
        unsafe {
            from_glib_full(ffi::gegl_metadata_store_get_timestamp(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gegl_metadata_store_get_title")]
    #[doc(alias = "get_title")]
    fn title(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::gegl_metadata_store_get_title(self.as_ref().to_glib_none().0))
        }
    }

    //#[doc(alias = "gegl_metadata_store_get_value")]
    //#[doc(alias = "get_value")]
    //fn value(&self, name: &str, value: /*Unimplemented*/glib::Value) {
    //    unsafe { TODO: call ffi:gegl_metadata_store_get_value() }
    //}

    #[doc(alias = "gegl_metadata_store_get_warning")]
    #[doc(alias = "get_warning")]
    fn warning(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::gegl_metadata_store_get_warning(self.as_ref().to_glib_none().0))
        }
    }

    #[doc(alias = "gegl_metadata_store_has_value")]
    fn has_value(&self, name: &str) -> bool {
        unsafe {
            from_glib(ffi::gegl_metadata_store_has_value(self.as_ref().to_glib_none().0, name.to_glib_none().0))
        }
    }

    //#[doc(alias = "gegl_metadata_store_register")]
    //fn register<P: FnOnce(&glib::Value) + 'static>(&self, local_name: &str, name: &str, transform: P) {
    //    unsafe { TODO: call ffi:gegl_metadata_store_register() }
    //}

    #[doc(alias = "gegl_metadata_store_set_artist")]
    #[doc(alias = "artist")]
    fn set_artist(&self, artist: &str) {
        unsafe {
            ffi::gegl_metadata_store_set_artist(self.as_ref().to_glib_none().0, artist.to_glib_none().0);
        }
    }

    #[doc(alias = "gegl_metadata_store_set_comment")]
    #[doc(alias = "comment")]
    fn set_comment(&self, comment: &str) {
        unsafe {
            ffi::gegl_metadata_store_set_comment(self.as_ref().to_glib_none().0, comment.to_glib_none().0);
        }
    }

    #[doc(alias = "gegl_metadata_store_set_copyright")]
    #[doc(alias = "copyright")]
    fn set_copyright(&self, copyright: &str) {
        unsafe {
            ffi::gegl_metadata_store_set_copyright(self.as_ref().to_glib_none().0, copyright.to_glib_none().0);
        }
    }

    #[doc(alias = "gegl_metadata_store_set_description")]
    #[doc(alias = "description")]
    fn set_description(&self, description: &str) {
        unsafe {
            ffi::gegl_metadata_store_set_description(self.as_ref().to_glib_none().0, description.to_glib_none().0);
        }
    }

    #[doc(alias = "gegl_metadata_store_set_disclaimer")]
    #[doc(alias = "disclaimer")]
    fn set_disclaimer(&self, disclaimer: &str) {
        unsafe {
            ffi::gegl_metadata_store_set_disclaimer(self.as_ref().to_glib_none().0, disclaimer.to_glib_none().0);
        }
    }

    #[doc(alias = "gegl_metadata_store_set_resolution_unit")]
    #[doc(alias = "resolution-unit")]
    fn set_resolution_unit(&self, unit: ResolutionUnit) {
        unsafe {
            ffi::gegl_metadata_store_set_resolution_unit(self.as_ref().to_glib_none().0, unit.into_glib());
        }
    }

    #[doc(alias = "gegl_metadata_store_set_resolution_x")]
    #[doc(alias = "resolution-x")]
    fn set_resolution_x(&self, resolution_x: f64) {
        unsafe {
            ffi::gegl_metadata_store_set_resolution_x(self.as_ref().to_glib_none().0, resolution_x);
        }
    }

    #[doc(alias = "gegl_metadata_store_set_resolution_y")]
    #[doc(alias = "resolution-y")]
    fn set_resolution_y(&self, resolution_y: f64) {
        unsafe {
            ffi::gegl_metadata_store_set_resolution_y(self.as_ref().to_glib_none().0, resolution_y);
        }
    }

    #[doc(alias = "gegl_metadata_store_set_software")]
    #[doc(alias = "software")]
    fn set_software(&self, software: &str) {
        unsafe {
            ffi::gegl_metadata_store_set_software(self.as_ref().to_glib_none().0, software.to_glib_none().0);
        }
    }

    #[doc(alias = "gegl_metadata_store_set_source")]
    #[doc(alias = "source")]
    fn set_source(&self, source: &str) {
        unsafe {
            ffi::gegl_metadata_store_set_source(self.as_ref().to_glib_none().0, source.to_glib_none().0);
        }
    }

    #[doc(alias = "gegl_metadata_store_set_string")]
    fn set_string(&self, name: &str, string: &str) {
        unsafe {
            ffi::gegl_metadata_store_set_string(self.as_ref().to_glib_none().0, name.to_glib_none().0, string.to_glib_none().0);
        }
    }

    #[doc(alias = "gegl_metadata_store_set_timestamp")]
    #[doc(alias = "timestamp")]
    fn set_timestamp(&self, timestamp: &glib::DateTime) {
        unsafe {
            ffi::gegl_metadata_store_set_timestamp(self.as_ref().to_glib_none().0, timestamp.to_glib_none().0);
        }
    }

    #[doc(alias = "gegl_metadata_store_set_title")]
    #[doc(alias = "title")]
    fn set_title(&self, title: &str) {
        unsafe {
            ffi::gegl_metadata_store_set_title(self.as_ref().to_glib_none().0, title.to_glib_none().0);
        }
    }

    #[doc(alias = "gegl_metadata_store_set_value")]
    fn set_value(&self, name: &str, value: &glib::Value) {
        unsafe {
            ffi::gegl_metadata_store_set_value(self.as_ref().to_glib_none().0, name.to_glib_none().0, value.to_glib_none().0);
        }
    }

    #[doc(alias = "gegl_metadata_store_set_warning")]
    #[doc(alias = "warning")]
    fn set_warning(&self, warning: &str) {
        unsafe {
            ffi::gegl_metadata_store_set_warning(self.as_ref().to_glib_none().0, warning.to_glib_none().0);
        }
    }

    #[doc(alias = "gegl_metadata_store_typeof_value")]
    fn typeof_value(&self, name: &str) -> glib::types::Type {
        unsafe {
            from_glib(ffi::gegl_metadata_store_typeof_value(self.as_ref().to_glib_none().0, name.to_glib_none().0))
        }
    }

    #[doc(alias = "changed")]
    fn connect_changed<F: Fn(&Self, &glib::ParamSpec) + 'static>(&self, detail: Option<&str>, f: F) -> SignalHandlerId {
        unsafe extern "C" fn changed_trampoline<P: IsA<MetadataStore>, F: Fn(&P, &glib::ParamSpec) + 'static>(this: *mut ffi::GeglMetadataStore, pspec: *mut glib::gobject_ffi::GParamSpec, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(MetadataStore::from_glib_borrow(this).unsafe_cast_ref(), &from_glib_borrow(pspec))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            let detailed_signal_name = detail.map(|name| { format!("changed::{name}\0") });
            let signal_name: &[u8] = detailed_signal_name.as_ref().map_or(&b"changed\0"[..], |n| n.as_bytes());
            connect_raw(self.as_ptr() as *mut _, signal_name.as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(changed_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    //#[doc(alias = "generate-value")]
    //fn connect_generate_value<Unsupported or ignored types>(&self, detail: Option<&str>, f: F) -> SignalHandlerId {
    //    InOut value: GObject.Value
    //}

    #[doc(alias = "mapped")]
    fn connect_mapped<F: Fn(&Self, &str, bool) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn mapped_trampoline<P: IsA<MetadataStore>, F: Fn(&P, &str, bool) + 'static>(this: *mut ffi::GeglMetadataStore, file_module: *mut std::ffi::c_char, exclude_unmapped: glib::ffi::gboolean, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(MetadataStore::from_glib_borrow(this).unsafe_cast_ref(), &glib::GString::from_glib_borrow(file_module), from_glib(exclude_unmapped))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"mapped".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(mapped_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    //#[doc(alias = "parse-value")]
    //fn connect_parse_value<Unsupported or ignored types>(&self, detail: Option<&str>, f: F) -> SignalHandlerId {
    //    InOut value: GObject.Value
    //}

    #[doc(alias = "unmapped")]
    fn connect_unmapped<F: Fn(&Self, &str, &str) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn unmapped_trampoline<P: IsA<MetadataStore>, F: Fn(&P, &str, &str) + 'static>(this: *mut ffi::GeglMetadataStore, file_module: *mut std::ffi::c_char, local_name: *mut std::ffi::c_char, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(MetadataStore::from_glib_borrow(this).unsafe_cast_ref(), &glib::GString::from_glib_borrow(file_module), &glib::GString::from_glib_borrow(local_name))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"unmapped".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(unmapped_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "artist")]
    fn connect_artist_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_artist_trampoline<P: IsA<MetadataStore>, F: Fn(&P) + 'static>(this: *mut ffi::GeglMetadataStore, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(MetadataStore::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::artist".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_artist_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "comment")]
    fn connect_comment_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_comment_trampoline<P: IsA<MetadataStore>, F: Fn(&P) + 'static>(this: *mut ffi::GeglMetadataStore, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(MetadataStore::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::comment".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_comment_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "copyright")]
    fn connect_copyright_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_copyright_trampoline<P: IsA<MetadataStore>, F: Fn(&P) + 'static>(this: *mut ffi::GeglMetadataStore, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(MetadataStore::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::copyright".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_copyright_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "description")]
    fn connect_description_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_description_trampoline<P: IsA<MetadataStore>, F: Fn(&P) + 'static>(this: *mut ffi::GeglMetadataStore, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(MetadataStore::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::description".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_description_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "disclaimer")]
    fn connect_disclaimer_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_disclaimer_trampoline<P: IsA<MetadataStore>, F: Fn(&P) + 'static>(this: *mut ffi::GeglMetadataStore, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(MetadataStore::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::disclaimer".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_disclaimer_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "file-module-name")]
    fn connect_file_module_name_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_file_module_name_trampoline<P: IsA<MetadataStore>, F: Fn(&P) + 'static>(this: *mut ffi::GeglMetadataStore, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(MetadataStore::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::file-module-name".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_file_module_name_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "resolution-unit")]
    fn connect_resolution_unit_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_resolution_unit_trampoline<P: IsA<MetadataStore>, F: Fn(&P) + 'static>(this: *mut ffi::GeglMetadataStore, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(MetadataStore::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::resolution-unit".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_resolution_unit_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "resolution-x")]
    fn connect_resolution_x_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_resolution_x_trampoline<P: IsA<MetadataStore>, F: Fn(&P) + 'static>(this: *mut ffi::GeglMetadataStore, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(MetadataStore::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::resolution-x".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_resolution_x_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "resolution-y")]
    fn connect_resolution_y_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_resolution_y_trampoline<P: IsA<MetadataStore>, F: Fn(&P) + 'static>(this: *mut ffi::GeglMetadataStore, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(MetadataStore::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::resolution-y".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_resolution_y_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "software")]
    fn connect_software_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_software_trampoline<P: IsA<MetadataStore>, F: Fn(&P) + 'static>(this: *mut ffi::GeglMetadataStore, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(MetadataStore::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::software".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_software_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "source")]
    fn connect_source_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_source_trampoline<P: IsA<MetadataStore>, F: Fn(&P) + 'static>(this: *mut ffi::GeglMetadataStore, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(MetadataStore::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::source".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_source_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "timestamp")]
    fn connect_timestamp_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_timestamp_trampoline<P: IsA<MetadataStore>, F: Fn(&P) + 'static>(this: *mut ffi::GeglMetadataStore, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(MetadataStore::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::timestamp".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_timestamp_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "title")]
    fn connect_title_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_title_trampoline<P: IsA<MetadataStore>, F: Fn(&P) + 'static>(this: *mut ffi::GeglMetadataStore, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(MetadataStore::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::title".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_title_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "warning")]
    fn connect_warning_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_warning_trampoline<P: IsA<MetadataStore>, F: Fn(&P) + 'static>(this: *mut ffi::GeglMetadataStore, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(MetadataStore::from_glib_borrow(this).unsafe_cast_ref())
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::warning".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_warning_trampoline::<Self, F> as *const ())), Box_::into_raw(f))
        }
    }
}

impl<O: IsA<MetadataStore>> MetadataStoreExt for O {}
