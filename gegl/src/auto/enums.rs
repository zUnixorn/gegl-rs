// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use crate::{ffi};
use glib::{prelude::*,translate::*};

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GeglAbyssPolicy")]
pub enum AbyssPolicy {
    #[doc(alias = "GEGL_ABYSS_NONE")]
    None,
    #[doc(alias = "GEGL_ABYSS_CLAMP")]
    Clamp,
    #[doc(alias = "GEGL_ABYSS_LOOP")]
    Loop,
    #[doc(alias = "GEGL_ABYSS_BLACK")]
    Black,
    #[doc(alias = "GEGL_ABYSS_WHITE")]
    White,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for AbyssPolicy {
    type GlibType = ffi::GeglAbyssPolicy;

    #[inline]
fn into_glib(self) -> ffi::GeglAbyssPolicy {
match self {
            Self::None => ffi::GEGL_ABYSS_NONE,
            Self::Clamp => ffi::GEGL_ABYSS_CLAMP,
            Self::Loop => ffi::GEGL_ABYSS_LOOP,
            Self::Black => ffi::GEGL_ABYSS_BLACK,
            Self::White => ffi::GEGL_ABYSS_WHITE,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::GeglAbyssPolicy> for AbyssPolicy {
    #[inline]
unsafe fn from_glib(value: ffi::GeglAbyssPolicy) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::GEGL_ABYSS_NONE => Self::None,
            ffi::GEGL_ABYSS_CLAMP => Self::Clamp,
            ffi::GEGL_ABYSS_LOOP => Self::Loop,
            ffi::GEGL_ABYSS_BLACK => Self::Black,
            ffi::GEGL_ABYSS_WHITE => Self::White,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for AbyssPolicy {
                #[inline]
    #[doc(alias = "gegl_abyss_policy_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::gegl_abyss_policy_get_type()) }
                }
            }

impl glib::HasParamSpec for AbyssPolicy {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for AbyssPolicy {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for AbyssPolicy {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for AbyssPolicy {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<AbyssPolicy> for glib::Value {
    #[inline]
    fn from(v: AbyssPolicy) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GeglBablVariant")]
pub enum BablVariant {
    #[doc(alias = "GEGL_BABL_VARIANT_FLOAT")]
    Float,
    #[doc(alias = "GEGL_BABL_VARIANT_LINEAR")]
    Linear,
    #[doc(alias = "GEGL_BABL_VARIANT_NONLINEAR")]
    NonLinear,
    #[doc(alias = "GEGL_BABL_VARIANT_PERCEPTUAL")]
    Perceptual,
    #[doc(alias = "GEGL_BABL_VARIANT_LINEAR_PREMULTIPLIED")]
    LinearPremultiplied,
    #[doc(alias = "GEGL_BABL_VARIANT_PERCEPTUAL_PREMULTIPLIED")]
    PerceptualPremultiplied,
    #[doc(alias = "GEGL_BABL_VARIANT_LINEAR_PREMULTIPLIED_IF_ALPHA")]
    LinearPremultipliedIfAlpha,
    #[doc(alias = "GEGL_BABL_VARIANT_PERCEPTUAL_PREMULTIPLIED_IF_ALPHA")]
    PerceptualPremultipliedIfAlpha,
    #[doc(alias = "GEGL_BABL_VARIANT_ALPHA")]
    AddAlpha,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for BablVariant {
    type GlibType = ffi::GeglBablVariant;

    #[inline]
fn into_glib(self) -> ffi::GeglBablVariant {
match self {
            Self::Float => ffi::GEGL_BABL_VARIANT_FLOAT,
            Self::Linear => ffi::GEGL_BABL_VARIANT_LINEAR,
            Self::NonLinear => ffi::GEGL_BABL_VARIANT_NONLINEAR,
            Self::Perceptual => ffi::GEGL_BABL_VARIANT_PERCEPTUAL,
            Self::LinearPremultiplied => ffi::GEGL_BABL_VARIANT_LINEAR_PREMULTIPLIED,
            Self::PerceptualPremultiplied => ffi::GEGL_BABL_VARIANT_PERCEPTUAL_PREMULTIPLIED,
            Self::LinearPremultipliedIfAlpha => ffi::GEGL_BABL_VARIANT_LINEAR_PREMULTIPLIED_IF_ALPHA,
            Self::PerceptualPremultipliedIfAlpha => ffi::GEGL_BABL_VARIANT_PERCEPTUAL_PREMULTIPLIED_IF_ALPHA,
            Self::AddAlpha => ffi::GEGL_BABL_VARIANT_ALPHA,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::GeglBablVariant> for BablVariant {
    #[inline]
unsafe fn from_glib(value: ffi::GeglBablVariant) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::GEGL_BABL_VARIANT_FLOAT => Self::Float,
            ffi::GEGL_BABL_VARIANT_LINEAR => Self::Linear,
            ffi::GEGL_BABL_VARIANT_NONLINEAR => Self::NonLinear,
            ffi::GEGL_BABL_VARIANT_PERCEPTUAL => Self::Perceptual,
            ffi::GEGL_BABL_VARIANT_LINEAR_PREMULTIPLIED => Self::LinearPremultiplied,
            ffi::GEGL_BABL_VARIANT_PERCEPTUAL_PREMULTIPLIED => Self::PerceptualPremultiplied,
            ffi::GEGL_BABL_VARIANT_LINEAR_PREMULTIPLIED_IF_ALPHA => Self::LinearPremultipliedIfAlpha,
            ffi::GEGL_BABL_VARIANT_PERCEPTUAL_PREMULTIPLIED_IF_ALPHA => Self::PerceptualPremultipliedIfAlpha,
            ffi::GEGL_BABL_VARIANT_ALPHA => Self::AddAlpha,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for BablVariant {
                #[inline]
    #[doc(alias = "gegl_babl_variant_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::gegl_babl_variant_get_type()) }
                }
            }

impl glib::HasParamSpec for BablVariant {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for BablVariant {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for BablVariant {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for BablVariant {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<BablVariant> for glib::Value {
    #[inline]
    fn from(v: BablVariant) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GeglCachePolicy")]
pub enum CachePolicy {
    #[doc(alias = "GEGL_CACHE_POLICY_AUTO")]
    Auto,
    #[doc(alias = "GEGL_CACHE_POLICY_NEVER")]
    Never,
    #[doc(alias = "GEGL_CACHE_POLICY_ALWAYS")]
    Always,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for CachePolicy {
    type GlibType = ffi::GeglCachePolicy;

    #[inline]
fn into_glib(self) -> ffi::GeglCachePolicy {
match self {
            Self::Auto => ffi::GEGL_CACHE_POLICY_AUTO,
            Self::Never => ffi::GEGL_CACHE_POLICY_NEVER,
            Self::Always => ffi::GEGL_CACHE_POLICY_ALWAYS,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::GeglCachePolicy> for CachePolicy {
    #[inline]
unsafe fn from_glib(value: ffi::GeglCachePolicy) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::GEGL_CACHE_POLICY_AUTO => Self::Auto,
            ffi::GEGL_CACHE_POLICY_NEVER => Self::Never,
            ffi::GEGL_CACHE_POLICY_ALWAYS => Self::Always,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for CachePolicy {
                #[inline]
    #[doc(alias = "gegl_cache_policy_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::gegl_cache_policy_get_type()) }
                }
            }

impl glib::HasParamSpec for CachePolicy {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for CachePolicy {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for CachePolicy {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for CachePolicy {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<CachePolicy> for glib::Value {
    #[inline]
    fn from(v: CachePolicy) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GeglDistanceMetric")]
pub enum DistanceMetric {
    #[doc(alias = "GEGL_DISTANCE_METRIC_EUCLIDEAN")]
    Euclidean,
    #[doc(alias = "GEGL_DISTANCE_METRIC_MANHATTAN")]
    Manhattan,
    #[doc(alias = "GEGL_DISTANCE_METRIC_CHEBYSHEV")]
    Chebyshev,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for DistanceMetric {
    type GlibType = ffi::GeglDistanceMetric;

    #[inline]
fn into_glib(self) -> ffi::GeglDistanceMetric {
match self {
            Self::Euclidean => ffi::GEGL_DISTANCE_METRIC_EUCLIDEAN,
            Self::Manhattan => ffi::GEGL_DISTANCE_METRIC_MANHATTAN,
            Self::Chebyshev => ffi::GEGL_DISTANCE_METRIC_CHEBYSHEV,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::GeglDistanceMetric> for DistanceMetric {
    #[inline]
unsafe fn from_glib(value: ffi::GeglDistanceMetric) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::GEGL_DISTANCE_METRIC_EUCLIDEAN => Self::Euclidean,
            ffi::GEGL_DISTANCE_METRIC_MANHATTAN => Self::Manhattan,
            ffi::GEGL_DISTANCE_METRIC_CHEBYSHEV => Self::Chebyshev,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for DistanceMetric {
                #[inline]
    #[doc(alias = "gegl_distance_metric_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::gegl_distance_metric_get_type()) }
                }
            }

impl glib::HasParamSpec for DistanceMetric {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for DistanceMetric {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for DistanceMetric {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for DistanceMetric {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<DistanceMetric> for glib::Value {
    #[inline]
    fn from(v: DistanceMetric) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GeglDitherMethod")]
pub enum DitherMethod {
    #[doc(alias = "GEGL_DITHER_NONE")]
    None,
    #[doc(alias = "GEGL_DITHER_FLOYD_STEINBERG")]
    FloydSteinberg,
    #[doc(alias = "GEGL_DITHER_BAYER")]
    Bayer,
    #[doc(alias = "GEGL_DITHER_RANDOM")]
    Random,
    #[doc(alias = "GEGL_DITHER_RANDOM_COVARIANT")]
    RandomCovariant,
    #[doc(alias = "GEGL_DITHER_ARITHMETIC_ADD")]
    Add,
    #[doc(alias = "GEGL_DITHER_ARITHMETIC_ADD_COVARIANT")]
    AddCovariant,
    #[doc(alias = "GEGL_DITHER_ARITHMETIC_XOR")]
    Xor,
    #[doc(alias = "GEGL_DITHER_ARITHMETIC_XOR_COVARIANT")]
    XorCovariant,
    #[doc(alias = "GEGL_DITHER_BLUE_NOISE")]
    BlueNoise,
    #[doc(alias = "GEGL_DITHER_BLUE_NOISE_COVARIANT")]
    BlueNoiseCovariant,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for DitherMethod {
    type GlibType = ffi::GeglDitherMethod;

    #[inline]
fn into_glib(self) -> ffi::GeglDitherMethod {
match self {
            Self::None => ffi::GEGL_DITHER_NONE,
            Self::FloydSteinberg => ffi::GEGL_DITHER_FLOYD_STEINBERG,
            Self::Bayer => ffi::GEGL_DITHER_BAYER,
            Self::Random => ffi::GEGL_DITHER_RANDOM,
            Self::RandomCovariant => ffi::GEGL_DITHER_RANDOM_COVARIANT,
            Self::Add => ffi::GEGL_DITHER_ARITHMETIC_ADD,
            Self::AddCovariant => ffi::GEGL_DITHER_ARITHMETIC_ADD_COVARIANT,
            Self::Xor => ffi::GEGL_DITHER_ARITHMETIC_XOR,
            Self::XorCovariant => ffi::GEGL_DITHER_ARITHMETIC_XOR_COVARIANT,
            Self::BlueNoise => ffi::GEGL_DITHER_BLUE_NOISE,
            Self::BlueNoiseCovariant => ffi::GEGL_DITHER_BLUE_NOISE_COVARIANT,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::GeglDitherMethod> for DitherMethod {
    #[inline]
unsafe fn from_glib(value: ffi::GeglDitherMethod) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::GEGL_DITHER_NONE => Self::None,
            ffi::GEGL_DITHER_FLOYD_STEINBERG => Self::FloydSteinberg,
            ffi::GEGL_DITHER_BAYER => Self::Bayer,
            ffi::GEGL_DITHER_RANDOM => Self::Random,
            ffi::GEGL_DITHER_RANDOM_COVARIANT => Self::RandomCovariant,
            ffi::GEGL_DITHER_ARITHMETIC_ADD => Self::Add,
            ffi::GEGL_DITHER_ARITHMETIC_ADD_COVARIANT => Self::AddCovariant,
            ffi::GEGL_DITHER_ARITHMETIC_XOR => Self::Xor,
            ffi::GEGL_DITHER_ARITHMETIC_XOR_COVARIANT => Self::XorCovariant,
            ffi::GEGL_DITHER_BLUE_NOISE => Self::BlueNoise,
            ffi::GEGL_DITHER_BLUE_NOISE_COVARIANT => Self::BlueNoiseCovariant,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for DitherMethod {
                #[inline]
    #[doc(alias = "gegl_dither_method_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::gegl_dither_method_get_type()) }
                }
            }

impl glib::HasParamSpec for DitherMethod {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for DitherMethod {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for DitherMethod {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for DitherMethod {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<DitherMethod> for glib::Value {
    #[inline]
    fn from(v: DitherMethod) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// Flags controlling the mapping strategy.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GeglMapFlags")]
pub enum MapFlags {
    /// Prevent further mapping from being registered.
    #[doc(alias = "GEGL_MAP_EXCLUDE_UNMAPPED")]
    MapExcludeUnmapped,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for MapFlags {
    type GlibType = ffi::GeglMapFlags;

    #[inline]
fn into_glib(self) -> ffi::GeglMapFlags {
match self {
            Self::MapExcludeUnmapped => ffi::GEGL_MAP_EXCLUDE_UNMAPPED,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::GeglMapFlags> for MapFlags {
    #[inline]
unsafe fn from_glib(value: ffi::GeglMapFlags) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::GEGL_MAP_EXCLUDE_UNMAPPED => Self::MapExcludeUnmapped,
            value => Self::__Unknown(value),
}
}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GeglOrientation")]
pub enum Orientation {
    #[doc(alias = "GEGL_ORIENTATION_HORIZONTAL")]
    Horizontal,
    #[doc(alias = "GEGL_ORIENTATION_VERTICAL")]
    Vertical,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for Orientation {
    type GlibType = ffi::GeglOrientation;

    #[inline]
fn into_glib(self) -> ffi::GeglOrientation {
match self {
            Self::Horizontal => ffi::GEGL_ORIENTATION_HORIZONTAL,
            Self::Vertical => ffi::GEGL_ORIENTATION_VERTICAL,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::GeglOrientation> for Orientation {
    #[inline]
unsafe fn from_glib(value: ffi::GeglOrientation) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::GEGL_ORIENTATION_HORIZONTAL => Self::Horizontal,
            ffi::GEGL_ORIENTATION_VERTICAL => Self::Vertical,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for Orientation {
                #[inline]
    #[doc(alias = "gegl_orientation_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::gegl_orientation_get_type()) }
                }
            }

impl glib::HasParamSpec for Orientation {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for Orientation {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for Orientation {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for Orientation {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<Orientation> for glib::Value {
    #[inline]
    fn from(v: Orientation) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GeglRectangleAlignment")]
pub enum RectangleAlignment {
    #[doc(alias = "GEGL_RECTANGLE_ALIGNMENT_SUBSET")]
    Subset,
    #[doc(alias = "GEGL_RECTANGLE_ALIGNMENT_SUPERSET")]
    Superset,
    #[doc(alias = "GEGL_RECTANGLE_ALIGNMENT_NEAREST")]
    Nearest,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for RectangleAlignment {
    type GlibType = ffi::GeglRectangleAlignment;

    #[inline]
fn into_glib(self) -> ffi::GeglRectangleAlignment {
match self {
            Self::Subset => ffi::GEGL_RECTANGLE_ALIGNMENT_SUBSET,
            Self::Superset => ffi::GEGL_RECTANGLE_ALIGNMENT_SUPERSET,
            Self::Nearest => ffi::GEGL_RECTANGLE_ALIGNMENT_NEAREST,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::GeglRectangleAlignment> for RectangleAlignment {
    #[inline]
unsafe fn from_glib(value: ffi::GeglRectangleAlignment) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::GEGL_RECTANGLE_ALIGNMENT_SUBSET => Self::Subset,
            ffi::GEGL_RECTANGLE_ALIGNMENT_SUPERSET => Self::Superset,
            ffi::GEGL_RECTANGLE_ALIGNMENT_NEAREST => Self::Nearest,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for RectangleAlignment {
                #[inline]
    #[doc(alias = "gegl_rectangle_alignment_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::gegl_rectangle_alignment_get_type()) }
                }
            }

impl glib::HasParamSpec for RectangleAlignment {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for RectangleAlignment {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for RectangleAlignment {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for RectangleAlignment {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<RectangleAlignment> for glib::Value {
    #[inline]
    fn from(v: RectangleAlignment) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

/// An enumerated type specifying resolution (density) units. If resolution
/// units are unknown, X and Y resolution specify the pixel aspect ratio.
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GeglResolutionUnit")]
pub enum ResolutionUnit {
    /// Unknown or resolution not applicable.
    #[doc(alias = "GEGL_RESOLUTION_UNIT_NONE")]
    None,
    /// Dots or pixels per inch.
    #[doc(alias = "GEGL_RESOLUTION_UNIT_DPI")]
    Dpi,
    /// Dots or pixels per metre.
    #[doc(alias = "GEGL_RESOLUTION_UNIT_DPM")]
    Dpm,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for ResolutionUnit {
    type GlibType = ffi::GeglResolutionUnit;

    #[inline]
fn into_glib(self) -> ffi::GeglResolutionUnit {
match self {
            Self::None => ffi::GEGL_RESOLUTION_UNIT_NONE,
            Self::Dpi => ffi::GEGL_RESOLUTION_UNIT_DPI,
            Self::Dpm => ffi::GEGL_RESOLUTION_UNIT_DPM,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::GeglResolutionUnit> for ResolutionUnit {
    #[inline]
unsafe fn from_glib(value: ffi::GeglResolutionUnit) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::GEGL_RESOLUTION_UNIT_NONE => Self::None,
            ffi::GEGL_RESOLUTION_UNIT_DPI => Self::Dpi,
            ffi::GEGL_RESOLUTION_UNIT_DPM => Self::Dpm,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for ResolutionUnit {
                #[inline]
    #[doc(alias = "gegl_resolution_unit_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::gegl_resolution_unit_get_type()) }
                }
            }

impl glib::HasParamSpec for ResolutionUnit {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for ResolutionUnit {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for ResolutionUnit {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for ResolutionUnit {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<ResolutionUnit> for glib::Value {
    #[inline]
    fn from(v: ResolutionUnit) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GeglSamplerType")]
pub enum SamplerType {
    #[doc(alias = "GEGL_SAMPLER_NEAREST")]
    Nearest,
    #[doc(alias = "GEGL_SAMPLER_LINEAR")]
    Linear,
    #[doc(alias = "GEGL_SAMPLER_CUBIC")]
    Cubic,
    #[doc(alias = "GEGL_SAMPLER_NOHALO")]
    Nohalo,
    #[doc(alias = "GEGL_SAMPLER_LOHALO")]
    Lohalo,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for SamplerType {
    type GlibType = ffi::GeglSamplerType;

    #[inline]
fn into_glib(self) -> ffi::GeglSamplerType {
match self {
            Self::Nearest => ffi::GEGL_SAMPLER_NEAREST,
            Self::Linear => ffi::GEGL_SAMPLER_LINEAR,
            Self::Cubic => ffi::GEGL_SAMPLER_CUBIC,
            Self::Nohalo => ffi::GEGL_SAMPLER_NOHALO,
            Self::Lohalo => ffi::GEGL_SAMPLER_LOHALO,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::GeglSamplerType> for SamplerType {
    #[inline]
unsafe fn from_glib(value: ffi::GeglSamplerType) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::GEGL_SAMPLER_NEAREST => Self::Nearest,
            ffi::GEGL_SAMPLER_LINEAR => Self::Linear,
            ffi::GEGL_SAMPLER_CUBIC => Self::Cubic,
            ffi::GEGL_SAMPLER_NOHALO => Self::Nohalo,
            ffi::GEGL_SAMPLER_LOHALO => Self::Lohalo,
            value => Self::__Unknown(value),
}
}
}

impl StaticType for SamplerType {
                #[inline]
    #[doc(alias = "gegl_sampler_type_get_type")]
   fn static_type() -> glib::Type {
                    unsafe { from_glib(ffi::gegl_sampler_type_get_type()) }
                }
            }

impl glib::HasParamSpec for SamplerType {
                type ParamSpec = glib::ParamSpecEnum;
                type SetValue = Self;
                type BuilderFn = fn(&str, Self) -> glib::ParamSpecEnumBuilder<Self>;
    
                fn param_spec_builder() -> Self::BuilderFn {
                    Self::ParamSpec::builder_with_default
                }
}

impl glib::value::ValueType for SamplerType {
    type Type = Self;
}

unsafe impl<'a> glib::value::FromValue<'a> for SamplerType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    #[inline]
    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_enum(value.to_glib_none().0))
    }
}

impl ToValue for SamplerType {
    #[inline]
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_enum(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    #[inline]
    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

impl From<SamplerType> for glib::Value {
    #[inline]
    fn from(v: SamplerType) -> Self {
        skip_assert_initialized!();
        ToValue::to_value(&v)
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GeglSplitStrategy")]
pub enum SplitStrategy {
    #[doc(alias = "GEGL_SPLIT_STRATEGY_AUTO")]
    Auto,
    #[doc(alias = "GEGL_SPLIT_STRATEGY_HORIZONTAL")]
    Horizontal,
    #[doc(alias = "GEGL_SPLIT_STRATEGY_VERTICAL")]
    Vertical,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for SplitStrategy {
    type GlibType = ffi::GeglSplitStrategy;

    #[inline]
fn into_glib(self) -> ffi::GeglSplitStrategy {
match self {
            Self::Auto => ffi::GEGL_SPLIT_STRATEGY_AUTO,
            Self::Horizontal => ffi::GEGL_SPLIT_STRATEGY_HORIZONTAL,
            Self::Vertical => ffi::GEGL_SPLIT_STRATEGY_VERTICAL,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::GeglSplitStrategy> for SplitStrategy {
    #[inline]
unsafe fn from_glib(value: ffi::GeglSplitStrategy) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::GEGL_SPLIT_STRATEGY_AUTO => Self::Auto,
            ffi::GEGL_SPLIT_STRATEGY_HORIZONTAL => Self::Horizontal,
            ffi::GEGL_SPLIT_STRATEGY_VERTICAL => Self::Vertical,
            value => Self::__Unknown(value),
}
}
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
#[non_exhaustive]
#[doc(alias = "GeglTileCommand")]
pub enum TileCommand {
    #[doc(alias = "GEGL_TILE_IDLE")]
    EglTileIdle,
    #[doc(alias = "GEGL_TILE_SET")]
    EglTileSet,
    #[doc(alias = "GEGL_TILE_GET")]
    EglTileGet,
    #[doc(alias = "GEGL_TILE_IS_CACHED")]
    EglTileIsCached,
    #[doc(alias = "GEGL_TILE_EXIST")]
    EglTileExist,
    #[doc(alias = "GEGL_TILE_VOID")]
    EglTileVoid,
    #[doc(alias = "GEGL_TILE_FLUSH")]
    EglTileFlush,
    #[doc(alias = "GEGL_TILE_REFETCH")]
    EglTileRefetch,
    #[doc(alias = "GEGL_TILE_REINIT")]
    EglTileReinit,
    #[doc(alias = "_GEGL_TILE_LAST_0_4_8_COMMAND")]
    GeglTileLast048Command,
    #[doc(alias = "GEGL_TILE_LAST_COMMAND")]
    EglTileLastCommand,
#[doc(hidden)]
    __Unknown(i32),
}

#[doc(hidden)]
impl IntoGlib for TileCommand {
    type GlibType = ffi::GeglTileCommand;

    #[inline]
fn into_glib(self) -> ffi::GeglTileCommand {
match self {
            Self::EglTileIdle => ffi::GEGL_TILE_IDLE,
            Self::EglTileSet => ffi::GEGL_TILE_SET,
            Self::EglTileGet => ffi::GEGL_TILE_GET,
            Self::EglTileIsCached => ffi::GEGL_TILE_IS_CACHED,
            Self::EglTileExist => ffi::GEGL_TILE_EXIST,
            Self::EglTileVoid => ffi::GEGL_TILE_VOID,
            Self::EglTileFlush => ffi::GEGL_TILE_FLUSH,
            Self::EglTileRefetch => ffi::GEGL_TILE_REFETCH,
            Self::EglTileReinit => ffi::GEGL_TILE_REINIT,
            Self::GeglTileLast048Command => ffi::_GEGL_TILE_LAST_0_4_8_COMMAND,
            Self::EglTileLastCommand => ffi::GEGL_TILE_LAST_COMMAND,
            Self::__Unknown(value) => value,
}
}
}

#[doc(hidden)]
impl FromGlib<ffi::GeglTileCommand> for TileCommand {
    #[inline]
unsafe fn from_glib(value: ffi::GeglTileCommand) -> Self {
        skip_assert_initialized!();
        
match value {
            ffi::GEGL_TILE_IDLE => Self::EglTileIdle,
            ffi::GEGL_TILE_SET => Self::EglTileSet,
            ffi::GEGL_TILE_GET => Self::EglTileGet,
            ffi::GEGL_TILE_IS_CACHED => Self::EglTileIsCached,
            ffi::GEGL_TILE_EXIST => Self::EglTileExist,
            ffi::GEGL_TILE_VOID => Self::EglTileVoid,
            ffi::GEGL_TILE_FLUSH => Self::EglTileFlush,
            ffi::GEGL_TILE_REFETCH => Self::EglTileRefetch,
            ffi::GEGL_TILE_REINIT => Self::EglTileReinit,
            ffi::_GEGL_TILE_LAST_0_4_8_COMMAND => Self::GeglTileLast048Command,
            ffi::GEGL_TILE_LAST_COMMAND => Self::EglTileLastCommand,
            value => Self::__Unknown(value),
}
}
}

