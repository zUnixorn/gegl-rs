// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use crate::{ffi,Buffer,RectangleAlignment};
use glib::{translate::*};

glib::wrapper! {
    pub struct Rectangle(BoxedInline<ffi::GeglRectangle>);

    match fn {
        copy => |ptr| glib::gobject_ffi::g_boxed_copy(ffi::gegl_rectangle_get_type(), ptr as *mut _) as *mut ffi::GeglRectangle,
        free => |ptr| glib::gobject_ffi::g_boxed_free(ffi::gegl_rectangle_get_type(), ptr as *mut _),
        type_ => || ffi::gegl_rectangle_get_type(),
    }
}

impl Rectangle {
    /// Creates a new rectangle set with the values from `x`, `y`, `width` and `height`.
    /// ## `x`
    /// upper left x coordinate
    /// ## `y`
    /// upper left y coordinate
    /// ## `width`
    /// width in pixels.
    /// ## `height`
    /// height in pixels.
    #[doc(alias = "gegl_rectangle_new")]
    pub fn new(x: i32, y: i32, width: u32, height: u32) -> Rectangle {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::gegl_rectangle_new(x, y, width, height))
        }
    }

    /// Aligns `rectangle` to a regular tile grid, of which `tile` is a representative
    /// tile, and stores the result in `self`.
    ///
    /// `alignment` can be one of:
    ///
    ///  GEGL_RECTANGLE_ALIGNMENT_SUBSET: Calculate the biggest aligned rectangle
    ///  contained in `rectangle`.
    ///
    ///  GEGL_RECTANGLE_ALIGNMENT_SUPERSET: Calculate the smallest aligned
    ///  rectangle containing `rectangle`.
    ///
    ///  GEGL_RECTANGLE_ALIGNMENT_NEAREST: Calculate the nearest aligned rectangle
    ///  to `rectangle`.
    ///
    /// `self` may point to the same object as `rectangle` or `tile`.
    ///
    /// Returns TRUE if the result is not empty.
    /// ## `rectangle`
    /// a [`Rectangle`][crate::Rectangle]
    /// ## `tile`
    /// a [`Rectangle`][crate::Rectangle]
    /// ## `alignment`
    /// a [`RectangleAlignment`][crate::RectangleAlignment] value
    #[doc(alias = "gegl_rectangle_align")]
    pub fn align(&mut self, rectangle: &Rectangle, tile: &Rectangle, alignment: RectangleAlignment) -> bool {
        unsafe {
            from_glib(ffi::gegl_rectangle_align(self.to_glib_none_mut().0, rectangle.to_glib_none().0, tile.to_glib_none().0, alignment.into_glib()))
        }
    }

    /// Aligns `rectangle` to the tile grid of `buffer`, and stores the result in
    /// `self`.
    ///
    /// `alignment` has the same meaning as for [`align()`][Self::align()].
    ///
    /// `self` may point to the same object as `rectangle`.
    ///
    /// Returns TRUE if the result is not empty.
    /// ## `rectangle`
    /// a [`Rectangle`][crate::Rectangle]
    /// ## `buffer`
    /// a [`Buffer`][crate::Buffer]
    /// ## `alignment`
    /// a [`RectangleAlignment`][crate::RectangleAlignment] value
    #[doc(alias = "gegl_rectangle_align_to_buffer")]
    pub fn align_to_buffer(&mut self, rectangle: &Rectangle, buffer: &Buffer, alignment: RectangleAlignment) -> bool {
        unsafe {
            from_glib(ffi::gegl_rectangle_align_to_buffer(self.to_glib_none_mut().0, rectangle.to_glib_none().0, buffer.to_glib_none().0, alignment.into_glib()))
        }
    }

    /// Computes the bounding box of the rectangles `source1` and `source2` and stores the
    /// resulting bounding box in `self`.
    ///
    /// `self` may point to the same object as `source1` or `source2`.
    /// ## `source1`
    /// a [`Rectangle`][crate::Rectangle]
    /// ## `source2`
    /// a [`Rectangle`][crate::Rectangle]
    #[doc(alias = "gegl_rectangle_bounding_box")]
    pub fn bounding_box(&mut self, source1: &Rectangle, source2: &Rectangle) {
        unsafe {
            ffi::gegl_rectangle_bounding_box(self.to_glib_none_mut().0, source1.to_glib_none().0, source2.to_glib_none().0);
        }
    }

    /// Checks if the [`Rectangle`][crate::Rectangle] `child` is fully contained within `self`.
    ///
    /// Returns TRUE if the `child` is fully contained in `self`.
    /// ## `child`
    /// a [`Rectangle`][crate::Rectangle]
    #[doc(alias = "gegl_rectangle_contains")]
    pub fn contains(&self, child: &Rectangle) -> bool {
        unsafe {
            from_glib(ffi::gegl_rectangle_contains(self.to_glib_none().0, child.to_glib_none().0))
        }
    }

    /// For debugging purposes, not stable API.
    #[doc(alias = "gegl_rectangle_dump")]
    pub fn dump(&self) {
        unsafe {
            ffi::gegl_rectangle_dump(self.to_glib_none().0);
        }
    }

    /// Create a new copy of `self`.
    ///
    /// # Returns
    ///
    /// a [`Rectangle`][crate::Rectangle]
    #[doc(alias = "gegl_rectangle_dup")]
#[must_use]
    pub fn dup(&self) -> Option<Rectangle> {
        unsafe {
            from_glib_full(ffi::gegl_rectangle_dup(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gegl_rectangle_equal")]
     fn equal(&self, rectangle2: &Rectangle) -> bool {
        unsafe {
            from_glib(ffi::gegl_rectangle_equal(self.to_glib_none().0, rectangle2.to_glib_none().0))
        }
    }

    /// Check if a rectangle is equal to a set of parameters.
    ///
    /// Returns TRUE if `self` and `x`,`y` `width` x `height` are equal.
    /// ## `x`
    /// X coordinate
    /// ## `y`
    /// Y coordinate
    /// ## `width`
    /// width of rectangle
    /// ## `height`
    /// height of rectangle
    #[doc(alias = "gegl_rectangle_equal_coords")]
    pub fn equal_coords(&self, x: i32, y: i32, width: i32, height: i32) -> bool {
        unsafe {
            from_glib(ffi::gegl_rectangle_equal_coords(self.to_glib_none().0, x, y, width, height))
        }
    }

    /// Calculates the intersection of two rectangles. If the rectangles do not
    /// intersect, dest's width and height are set to 0 and its x and y values
    /// are undefined.
    ///
    /// `self` may point to the same object as `src1` or `src2`.
    ///
    /// Returns TRUE if the rectangles intersect.
    /// ## `src1`
    /// a [`Rectangle`][crate::Rectangle]
    /// ## `src2`
    /// a [`Rectangle`][crate::Rectangle]
    #[doc(alias = "gegl_rectangle_intersect")]
    pub fn intersect(&mut self, src1: &Rectangle, src2: &Rectangle) -> bool {
        unsafe {
            from_glib(ffi::gegl_rectangle_intersect(self.to_glib_none_mut().0, src1.to_glib_none().0, src2.to_glib_none().0))
        }
    }

    /// Check if a rectangle has zero area.
    ///
    /// Returns TRUE if the width or height of `self` is 0.
    #[doc(alias = "gegl_rectangle_is_empty")]
    pub fn is_empty(&self) -> bool {
        unsafe {
            from_glib(ffi::gegl_rectangle_is_empty(self.to_glib_none().0))
        }
    }

    /// Returns TRUE if the GeglRectangle represents an infininte plane,
    /// FALSE otherwise.
    #[doc(alias = "gegl_rectangle_is_infinite_plane")]
    pub fn is_infinite_plane(&self) -> bool {
        unsafe {
            from_glib(ffi::gegl_rectangle_is_infinite_plane(self.to_glib_none().0))
        }
    }

    /// Sets the `x`, `y`, `width` and `height` on `self`.
    /// ## `x`
    /// upper left x coordinate
    /// ## `y`
    /// upper left y coordinate
    /// ## `width`
    /// width in pixels.
    /// ## `height`
    /// height in pixels.
    #[doc(alias = "gegl_rectangle_set")]
    pub fn set(&mut self, x: i32, y: i32, width: u32, height: u32) {
        unsafe {
            ffi::gegl_rectangle_set(self.to_glib_none_mut().0, x, y, width, height);
        }
    }

    /// Subtracts `subtrahend` from `minuend`, and stores the resulting rectangles in
    /// `self`. Between 0 and 4 disjoint rectangles may be produced.
    ///
    /// `self` may contain `minuend` or `subtrahend`.
    ///
    /// Returns the number of resulting rectangles.
    /// ## `minuend`
    /// a [`Rectangle`][crate::Rectangle]
    /// ## `subtrahend`
    /// a [`Rectangle`][crate::Rectangle]
    #[doc(alias = "gegl_rectangle_subtract")]
    pub fn subtract(&mut self, minuend: &Rectangle, subtrahend: &Rectangle) -> i32 {
        unsafe {
            ffi::gegl_rectangle_subtract(self.to_glib_none_mut().0, minuend.to_glib_none().0, subtrahend.to_glib_none().0)
        }
    }

    /// Computes the bounding box of the area formed by subtracting `subtrahend`
    /// from `minuend`, and stores the result in `self`.
    ///
    /// `self` may point to the same object as `minuend` or `subtrahend`.
    ///
    /// Returns TRUE if the result is not empty.
    /// ## `minuend`
    /// a [`Rectangle`][crate::Rectangle]
    /// ## `subtrahend`
    /// a [`Rectangle`][crate::Rectangle]
    #[doc(alias = "gegl_rectangle_subtract_bounding_box")]
    pub fn subtract_bounding_box(&mut self, minuend: &Rectangle, subtrahend: &Rectangle) -> bool {
        unsafe {
            from_glib(ffi::gegl_rectangle_subtract_bounding_box(self.to_glib_none_mut().0, minuend.to_glib_none().0, subtrahend.to_glib_none().0))
        }
    }

    /// Computes the symmetric difference of the rectangles `source1` and `source2`,
    /// and stores the resulting rectangles in `self`. Between 0 and 4
    /// disjoint rectangles may be produced.
    ///
    /// `self` may contain `rectangle1` or `rectangle2`.
    ///
    /// Returns the number of resulting rectangles.
    /// ## `source1`
    /// a [`Rectangle`][crate::Rectangle]
    /// ## `source2`
    /// a [`Rectangle`][crate::Rectangle]
    #[doc(alias = "gegl_rectangle_xor")]
    pub fn xor(&mut self, source1: &Rectangle, source2: &Rectangle) -> i32 {
        unsafe {
            ffi::gegl_rectangle_xor(self.to_glib_none_mut().0, source1.to_glib_none().0, source2.to_glib_none().0)
        }
    }
}

impl PartialEq for Rectangle {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.equal(other)
    }
}

impl Eq for Rectangle {}
