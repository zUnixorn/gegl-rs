// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use crate::{ffi,Matrix3};
use glib::{translate::*};

glib::wrapper! {
    #[doc(alias = "GeglPath")]
    pub struct Path(Object<ffi::GeglPath, ffi::GeglPathClass>);

    match fn {
        type_ => || ffi::gegl_path_get_type(),
    }
}

impl Path {
    #[doc(alias = "gegl_path_new")]
    pub fn new() -> Path {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::gegl_path_new())
        }
    }

    #[doc(alias = "gegl_path_new_from_string")]
    #[doc(alias = "new_from_string")]
    pub fn from_string(instructions: &str) -> Path {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::gegl_path_new_from_string(instructions.to_glib_none().0))
        }
    }

    //#[doc(alias = "gegl_path_append")]
    //pub fn append(&self, : /*Unknown conversion*//*Unimplemented*/Basic: VarArgs) {
    //    unsafe { TODO: call ffi:gegl_path_append() }
    //}

    #[doc(alias = "gegl_path_calc")]
    pub fn calc(&self, pos: f64) -> Option<(f64, f64)> {
        unsafe {
            let mut x = std::mem::MaybeUninit::uninit();
            let mut y = std::mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gegl_path_calc(self.to_glib_none().0, pos, x.as_mut_ptr(), y.as_mut_ptr()));
            if ret { Some((x.assume_init(), y.assume_init())) } else { None }
        }
    }

    #[doc(alias = "gegl_path_calc_y_for_x")]
    pub fn calc_y_for_x(&self, x: f64) -> (i32, f64) {
        unsafe {
            let mut y = std::mem::MaybeUninit::uninit();
            let ret = ffi::gegl_path_calc_y_for_x(self.to_glib_none().0, x, y.as_mut_ptr());
            (ret, y.assume_init())
        }
    }

    #[doc(alias = "gegl_path_clear")]
    pub fn clear(&self) {
        unsafe {
            ffi::gegl_path_clear(self.to_glib_none().0);
        }
    }

    #[doc(alias = "gegl_path_closest_point")]
    pub fn closest_point(&self, x: f64, y: f64) -> (f64, f64, f64, i32) {
        unsafe {
            let mut on_path_x = std::mem::MaybeUninit::uninit();
            let mut on_path_y = std::mem::MaybeUninit::uninit();
            let mut node_pos_before = std::mem::MaybeUninit::uninit();
            let ret = ffi::gegl_path_closest_point(self.to_glib_none().0, x, y, on_path_x.as_mut_ptr(), on_path_y.as_mut_ptr(), node_pos_before.as_mut_ptr());
            (ret, on_path_x.assume_init(), on_path_y.assume_init(), node_pos_before.assume_init())
        }
    }

    #[doc(alias = "gegl_path_dirty")]
    pub fn dirty(&self) {
        unsafe {
            ffi::gegl_path_dirty(self.to_glib_none().0);
        }
    }

    //#[doc(alias = "gegl_path_foreach")]
    //pub fn foreach(&self, each_item: /*Unimplemented*/FnMut(/*Ignored*/PathItem), user_data: /*Unimplemented*/Option<Basic: Pointer>) {
    //    unsafe { TODO: call ffi:gegl_path_foreach() }
    //}

    //#[doc(alias = "gegl_path_foreach_flat")]
    //pub fn foreach_flat(&self, each_item: /*Unimplemented*/FnMut(/*Ignored*/PathItem), user_data: /*Unimplemented*/Option<Basic: Pointer>) {
    //    unsafe { TODO: call ffi:gegl_path_foreach_flat() }
    //}

    #[doc(alias = "gegl_path_freeze")]
    pub fn freeze(&self) {
        unsafe {
            ffi::gegl_path_freeze(self.to_glib_none().0);
        }
    }

    #[doc(alias = "gegl_path_get_bounds")]
    #[doc(alias = "get_bounds")]
    pub fn bounds(&self) -> (f64, f64, f64, f64) {
        unsafe {
            let mut min_x = std::mem::MaybeUninit::uninit();
            let mut max_x = std::mem::MaybeUninit::uninit();
            let mut min_y = std::mem::MaybeUninit::uninit();
            let mut max_y = std::mem::MaybeUninit::uninit();
            ffi::gegl_path_get_bounds(self.to_glib_none().0, min_x.as_mut_ptr(), max_x.as_mut_ptr(), min_y.as_mut_ptr(), max_y.as_mut_ptr());
            (min_x.assume_init(), max_x.assume_init(), min_y.assume_init(), max_y.assume_init())
        }
    }

    //#[doc(alias = "gegl_path_get_flat_path")]
    //#[doc(alias = "get_flat_path")]
    //pub fn flat_path(&self) -> /*Ignored*/Option<PathList> {
    //    unsafe { TODO: call ffi:gegl_path_get_flat_path() }
    //}

    #[doc(alias = "gegl_path_get_length")]
    #[doc(alias = "get_length")]
    pub fn length(&self) -> f64 {
        unsafe {
            ffi::gegl_path_get_length(self.to_glib_none().0)
        }
    }

    #[doc(alias = "gegl_path_get_n_nodes")]
    #[doc(alias = "get_n_nodes")]
    pub fn n_nodes(&self) -> i32 {
        unsafe {
            ffi::gegl_path_get_n_nodes(self.to_glib_none().0)
        }
    }

    //#[doc(alias = "gegl_path_get_node")]
    //#[doc(alias = "get_node")]
    //pub fn node(&self, index: i32, node: /*Ignored*/PathItem) -> bool {
    //    unsafe { TODO: call ffi:gegl_path_get_node() }
    //}

    //#[doc(alias = "gegl_path_get_path")]
    //#[doc(alias = "get_path")]
    //pub fn path(&self) -> /*Ignored*/Option<PathList> {
    //    unsafe { TODO: call ffi:gegl_path_get_path() }
    //}

    //#[doc(alias = "gegl_path_insert_node")]
    //pub fn insert_node(&self, pos: i32, node: /*Ignored*/&PathItem) {
    //    unsafe { TODO: call ffi:gegl_path_insert_node() }
    //}

    #[doc(alias = "gegl_path_is_empty")]
    pub fn is_empty(&self) -> bool {
        unsafe {
            from_glib(ffi::gegl_path_is_empty(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gegl_path_parse_string")]
    pub fn parse_string(&self, instructions: &str) {
        unsafe {
            ffi::gegl_path_parse_string(self.to_glib_none().0, instructions.to_glib_none().0);
        }
    }

    #[doc(alias = "gegl_path_remove_node")]
    pub fn remove_node(&self, pos: i32) {
        unsafe {
            ffi::gegl_path_remove_node(self.to_glib_none().0, pos);
        }
    }

    //#[doc(alias = "gegl_path_replace_node")]
    //pub fn replace_node(&self, pos: i32, node: /*Ignored*/&PathItem) {
    //    unsafe { TODO: call ffi:gegl_path_replace_node() }
    //}

    #[doc(alias = "gegl_path_set_matrix")]
    pub fn set_matrix(&self, matrix: &mut Matrix3) {
        unsafe {
            ffi::gegl_path_set_matrix(self.to_glib_none().0, matrix.to_glib_none_mut().0);
        }
    }

    #[doc(alias = "gegl_path_thaw")]
    pub fn thaw(&self) {
        unsafe {
            ffi::gegl_path_thaw(self.to_glib_none().0);
        }
    }

    #[doc(alias = "gegl_path_to_string")]
    #[doc(alias = "to_string")]
    pub fn to_str(&self) -> glib::GString {
        unsafe {
            from_glib_full(ffi::gegl_path_to_string(self.to_glib_none().0))
        }
    }

    //#[doc(alias = "gegl_path_add_flattener")]
    //pub fn add_flattener(func: /*Unimplemented*/Fn() -> /*Ignored*/PathList) {
    //    unsafe { TODO: call ffi:gegl_path_add_flattener() }
    //}

    #[doc(alias = "gegl_path_add_type")]
    pub fn add_type(type_: glib::Char, items: i32, description: &str) {
        assert_initialized_main_thread!();
        unsafe {
            ffi::gegl_path_add_type(type_.into_glib(), items, description.to_glib_none().0);
        }
    }

    //#[doc(alias = "changed")]
    //pub fn connect_changed<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Unimplemented object: *.Pointer
    //}
}

impl Default for Path {
                     fn default() -> Self {
                         Self::new()
                     }
                 }

impl std::fmt::Display for Path {
    #[inline]
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.write_str(&self.to_str())
    }
}
