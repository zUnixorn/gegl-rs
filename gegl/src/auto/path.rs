// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use crate::{ffi,Matrix3};
use glib::{translate::*};

glib::wrapper! {
    ///
    ///
    /// ## Signals
    ///
    ///
    /// #### `changed`
    ///
    #[doc(alias = "GeglPath")]
    pub struct Path(Object<ffi::GeglPath, ffi::GeglPathClass>);

    match fn {
        type_ => || ffi::gegl_path_get_type(),
    }
}

impl Path {
    /// Creates a new [`Path`][crate::Path] with no nodes.
    ///
    /// Returns the newly created [`Path`][crate::Path]
    #[doc(alias = "gegl_path_new")]
    pub fn new() -> Path {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::gegl_path_new())
        }
    }

    /// Creates a new [`Path`][crate::Path] with the nodes described in the string
    /// `instructions`. See [`parse_string()`][Self::parse_string()] for details of the
    /// format of the string.
    ///
    /// Returns the newly created [`Path`][crate::Path]
    /// ## `instructions`
    /// a string describing the path.
    #[doc(alias = "gegl_path_new_from_string")]
    #[doc(alias = "new_from_string")]
    pub fn from_string(instructions: &str) -> Path {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::gegl_path_new_from_string(instructions.to_glib_none().0))
        }
    }

    //#[doc(alias = "gegl_path_append")]
    //pub fn append(&self, : /*Unknown conversion*//*Unimplemented*/Basic: VarArgs) {
    //    unsafe { TODO: call ffi:gegl_path_append() }
    //}

    /// Compute the coordinates of the path at the `position` (length measured from
    /// start of path, not including discontinuities).
    /// ## `pos`
    /// how far along the path.
    ///
    /// # Returns
    ///
    ///
    /// ## `x`
    /// return location for x coordinate.
    ///
    /// ## `y`
    /// return location for y coordinate
    #[doc(alias = "gegl_path_calc")]
    pub fn calc(&self, pos: f64) -> Option<(f64, f64)> {
        unsafe {
            let mut x = std::mem::MaybeUninit::uninit();
            let mut y = std::mem::MaybeUninit::uninit();
            let ret = from_glib(ffi::gegl_path_calc(self.to_glib_none().0, pos, x.as_mut_ptr(), y.as_mut_ptr()));
            if ret { Some((x.assume_init(), y.assume_init())) } else { None }
        }
    }

    /// Compute a corresponding y coordinate for a given x input coordinate,
    /// returns 0 if computed correctly and -1 if the path doesn't exist for the
    /// specified x coordinate.
    /// ## `x`
    /// x coordinate to compute for
    ///
    /// # Returns
    ///
    ///
    /// ## `y`
    /// return location for y coordinate
    #[doc(alias = "gegl_path_calc_y_for_x")]
    pub fn calc_y_for_x(&self, x: f64) -> (i32, f64) {
        unsafe {
            let mut y = std::mem::MaybeUninit::uninit();
            let ret = ffi::gegl_path_calc_y_for_x(self.to_glib_none().0, x, y.as_mut_ptr());
            (ret, y.assume_init())
        }
    }

    /// Remove all nods from a `self`.
    #[doc(alias = "gegl_path_clear")]
    pub fn clear(&self) {
        unsafe {
            ffi::gegl_path_clear(self.to_glib_none().0);
        }
    }

    /// Figure out what and where on a path is closest to arbitrary coordinates.
    ///
    /// Returns the length along the path where the closest point was encountered.
    /// ## `x`
    /// x coordinate.
    /// ## `y`
    /// y coordinate
    ///
    /// # Returns
    ///
    ///
    /// ## `on_path_x`
    /// return location for x coordinate on the path that was closest
    ///
    /// ## `on_path_y`
    /// return location for y coordinate on the path that was closest
    ///
    /// ## `node_pos_before`
    /// the node position interpreted before this position
    /// was deemed the closest coordinate.
    #[doc(alias = "gegl_path_closest_point")]
    pub fn closest_point(&self, x: f64, y: f64) -> (f64, f64, f64, i32) {
        unsafe {
            let mut on_path_x = std::mem::MaybeUninit::uninit();
            let mut on_path_y = std::mem::MaybeUninit::uninit();
            let mut node_pos_before = std::mem::MaybeUninit::uninit();
            let ret = ffi::gegl_path_closest_point(self.to_glib_none().0, x, y, on_path_x.as_mut_ptr(), on_path_y.as_mut_ptr(), node_pos_before.as_mut_ptr());
            (ret, on_path_x.assume_init(), on_path_y.assume_init(), node_pos_before.assume_init())
        }
    }

    /// Marks the path as dirty and issues an invalidation for the path rendering,
    /// use this if modifying the values of a GeglPathPoint inline.
    #[doc(alias = "gegl_path_dirty")]
    pub fn dirty(&self) {
        unsafe {
            ffi::gegl_path_dirty(self.to_glib_none().0);
        }
    }

    //#[doc(alias = "gegl_path_foreach")]
    //pub fn foreach(&self, each_item: /*Unimplemented*/FnMut(/*Ignored*/PathItem), user_data: /*Unimplemented*/Option<Basic: Pointer>) {
    //    unsafe { TODO: call ffi:gegl_path_foreach() }
    //}

    //#[doc(alias = "gegl_path_foreach_flat")]
    //pub fn foreach_flat(&self, each_item: /*Unimplemented*/FnMut(/*Ignored*/PathItem), user_data: /*Unimplemented*/Option<Basic: Pointer>) {
    //    unsafe { TODO: call ffi:gegl_path_foreach_flat() }
    //}

    /// Make the [`Path`][crate::Path] stop firing signals as it changes must be paired with a
    /// [`thaw()`][Self::thaw()] for the signals to start again.
    #[doc(alias = "gegl_path_freeze")]
    pub fn freeze(&self) {
        unsafe {
            ffi::gegl_path_freeze(self.to_glib_none().0);
        }
    }

    /// Compute the bounding box of a path.
    ///
    /// # Returns
    ///
    ///
    /// ## `min_x`
    /// return location for minimum x coordinate
    ///
    /// ## `max_x`
    /// return location for maximum x coordinate
    ///
    /// ## `min_y`
    /// return location for minimum y coordinate
    ///
    /// ## `max_y`
    /// return location for maximum y coordinate
    #[doc(alias = "gegl_path_get_bounds")]
    #[doc(alias = "get_bounds")]
    pub fn bounds(&self) -> (f64, f64, f64, f64) {
        unsafe {
            let mut min_x = std::mem::MaybeUninit::uninit();
            let mut max_x = std::mem::MaybeUninit::uninit();
            let mut min_y = std::mem::MaybeUninit::uninit();
            let mut max_y = std::mem::MaybeUninit::uninit();
            ffi::gegl_path_get_bounds(self.to_glib_none().0, min_x.as_mut_ptr(), max_x.as_mut_ptr(), min_y.as_mut_ptr(), max_y.as_mut_ptr());
            (min_x.assume_init(), max_x.assume_init(), min_y.assume_init(), max_y.assume_init())
        }
    }

    //#[doc(alias = "gegl_path_get_flat_path")]
    //#[doc(alias = "get_flat_path")]
    //pub fn flat_path(&self) -> /*Ignored*/Option<PathList> {
    //    unsafe { TODO: call ffi:gegl_path_get_flat_path() }
    //}

    /// Returns the total length of the path.
    ///
    /// # Returns
    ///
    /// the length of the path.
    #[doc(alias = "gegl_path_get_length")]
    #[doc(alias = "get_length")]
    pub fn length(&self) -> f64 {
        unsafe {
            ffi::gegl_path_get_length(self.to_glib_none().0)
        }
    }

    /// Retrieves the number of nodes in the path.
    ///
    /// # Returns
    ///
    /// the number of nodes in the path.
    #[doc(alias = "gegl_path_get_n_nodes")]
    #[doc(alias = "get_n_nodes")]
    pub fn n_nodes(&self) -> i32 {
        unsafe {
            ffi::gegl_path_get_n_nodes(self.to_glib_none().0)
        }
    }

    //#[doc(alias = "gegl_path_get_node")]
    //#[doc(alias = "get_node")]
    //pub fn node(&self, index: i32, node: /*Ignored*/PathItem) -> bool {
    //    unsafe { TODO: call ffi:gegl_path_get_node() }
    //}

    //#[doc(alias = "gegl_path_get_path")]
    //#[doc(alias = "get_path")]
    //pub fn path(&self) -> /*Ignored*/Option<PathList> {
    //    unsafe { TODO: call ffi:gegl_path_get_path() }
    //}

    //#[doc(alias = "gegl_path_insert_node")]
    //pub fn insert_node(&self, pos: i32, node: /*Ignored*/&PathItem) {
    //    unsafe { TODO: call ffi:gegl_path_insert_node() }
    //}

    /// Check if the path contains any nodes.
    ///
    /// Returns TRUE if the path has no nodes.
    #[doc(alias = "gegl_path_is_empty")]
    pub fn is_empty(&self) -> bool {
        unsafe {
            from_glib(ffi::gegl_path_is_empty(self.to_glib_none().0))
        }
    }

    /// Parses `instructions` and appends corresponding nodes to path (call
    /// `gegl_path_clean()` first if you want to replace the existing path.
    /// ## `instructions`
    /// a string describing a path.
    #[doc(alias = "gegl_path_parse_string")]
    pub fn parse_string(&self, instructions: &str) {
        unsafe {
            ffi::gegl_path_parse_string(self.to_glib_none().0, instructions.to_glib_none().0);
        }
    }

    /// Removes the node number `pos` in `self`.
    /// ## `pos`
    /// a node in the path.
    #[doc(alias = "gegl_path_remove_node")]
    pub fn remove_node(&self, pos: i32) {
        unsafe {
            ffi::gegl_path_remove_node(self.to_glib_none().0, pos);
        }
    }

    //#[doc(alias = "gegl_path_replace_node")]
    //pub fn replace_node(&self, pos: i32, node: /*Ignored*/&PathItem) {
    //    unsafe { TODO: call ffi:gegl_path_replace_node() }
    //}

    /// Set the transformation matrix of the path.
    ///
    /// The path is transformed through this matrix when being evaluated,
    /// causing the calculated positions and length to be changed by the transform.
    /// ## `matrix`
    /// a [`Matrix3`][crate::Matrix3] to copy the matrix from
    #[doc(alias = "gegl_path_set_matrix")]
    pub fn set_matrix(&self, matrix: &mut Matrix3) {
        unsafe {
            ffi::gegl_path_set_matrix(self.to_glib_none().0, matrix.to_glib_none_mut().0);
        }
    }

    /// Restart firing signals (unless the path has been frozen multiple times).
    #[doc(alias = "gegl_path_thaw")]
    pub fn thaw(&self) {
        unsafe {
            ffi::gegl_path_thaw(self.to_glib_none().0);
        }
    }

    /// Serialize the paths nodes to a string.
    ///
    /// # Returns
    ///
    /// return a string with instructions describing the string you
    /// need to free this with `g_free()`.
    #[doc(alias = "gegl_path_to_string")]
    #[doc(alias = "to_string")]
    pub fn to_str(&self) -> glib::GString {
        unsafe {
            from_glib_full(ffi::gegl_path_to_string(self.to_glib_none().0))
        }
    }

    //#[doc(alias = "gegl_path_add_flattener")]
    //pub fn add_flattener(func: /*Unimplemented*/Fn() -> /*Ignored*/PathList) {
    //    unsafe { TODO: call ffi:gegl_path_add_flattener() }
    //}

    /// Adds a new type to the path system, FIXME this should probably
    /// return something on registration conflicts, for now it expects
    /// all registered paths to be aware of each other.
    /// ## `type_`
    /// a gchar to recognize in path descriptions.
    /// ## `items`
    /// the number of floating point data items the instruction takes
    /// ## `description`
    /// a human readable description of this entry
    #[doc(alias = "gegl_path_add_type")]
    pub fn add_type(type_: glib::Char, items: i32, description: &str) {
        assert_initialized_main_thread!();
        unsafe {
            ffi::gegl_path_add_type(type_.into_glib(), items, description.to_glib_none().0);
        }
    }

    //#[doc(alias = "changed")]
    //pub fn connect_changed<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Unimplemented object: *.Pointer
    //}
}

impl Default for Path {
                     fn default() -> Self {
                         Self::new()
                     }
                 }

impl std::fmt::Display for Path {
    #[inline]
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.write_str(&self.to_str())
    }
}
