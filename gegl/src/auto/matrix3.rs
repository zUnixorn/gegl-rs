// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use crate::{ffi};
use glib::{translate::*};

glib::wrapper! {
    #[derive(Debug)]
    pub struct Matrix3(Boxed<ffi::GeglMatrix3>);

    match fn {
        copy => |ptr| glib::gobject_ffi::g_boxed_copy(ffi::gegl_matrix3_get_type(), ptr as *mut _) as *mut ffi::GeglMatrix3,
        free => |ptr| glib::gobject_ffi::g_boxed_free(ffi::gegl_matrix3_get_type(), ptr as *mut _),
        type_ => || ffi::gegl_matrix3_get_type(),
    }
}

impl Matrix3 {
    #[doc(alias = "gegl_matrix3_new")]
    pub fn new() -> Matrix3 {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::gegl_matrix3_new())
        }
    }

    #[doc(alias = "gegl_matrix3_copy_into")]
    pub fn copy_into(&mut self, src: &Matrix3) {
        unsafe {
            ffi::gegl_matrix3_copy_into(self.to_glib_none_mut().0, src.to_glib_none().0);
        }
    }

    #[doc(alias = "gegl_matrix3_determinant")]
    pub fn determinant(&self) -> f64 {
        unsafe {
            ffi::gegl_matrix3_determinant(self.to_glib_none().0)
        }
    }

    #[doc(alias = "gegl_matrix3_identity")]
    pub fn identity(&mut self) {
        unsafe {
            ffi::gegl_matrix3_identity(self.to_glib_none_mut().0);
        }
    }

    #[doc(alias = "gegl_matrix3_invert")]
    pub fn invert(&mut self) {
        unsafe {
            ffi::gegl_matrix3_invert(self.to_glib_none_mut().0);
        }
    }

    #[doc(alias = "gegl_matrix3_is_affine")]
    pub fn is_affine(&self) -> bool {
        unsafe {
            from_glib(ffi::gegl_matrix3_is_affine(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gegl_matrix3_is_identity")]
    pub fn is_identity(&self) -> bool {
        unsafe {
            from_glib(ffi::gegl_matrix3_is_identity(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gegl_matrix3_is_scale")]
    pub fn is_scale(&self) -> bool {
        unsafe {
            from_glib(ffi::gegl_matrix3_is_scale(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gegl_matrix3_is_translate")]
    pub fn is_translate(&self) -> bool {
        unsafe {
            from_glib(ffi::gegl_matrix3_is_translate(self.to_glib_none().0))
        }
    }

    #[doc(alias = "gegl_matrix3_multiply")]
    pub fn multiply(&self, right: &Matrix3, product: &mut Matrix3) {
        unsafe {
            ffi::gegl_matrix3_multiply(self.to_glib_none().0, right.to_glib_none().0, product.to_glib_none_mut().0);
        }
    }

    #[doc(alias = "gegl_matrix3_originate")]
    pub fn originate(&mut self, x: f64, y: f64) {
        unsafe {
            ffi::gegl_matrix3_originate(self.to_glib_none_mut().0, x, y);
        }
    }

    #[doc(alias = "gegl_matrix3_parse_string")]
    pub fn parse_string(&mut self, string: &str) {
        unsafe {
            ffi::gegl_matrix3_parse_string(self.to_glib_none_mut().0, string.to_glib_none().0);
        }
    }

    #[doc(alias = "gegl_matrix3_round_error")]
    pub fn round_error(&mut self) {
        unsafe {
            ffi::gegl_matrix3_round_error(self.to_glib_none_mut().0);
        }
    }
}

impl Default for Matrix3 {
                     fn default() -> Self {
                         Self::new()
                     }
                 }
