// This file was generated by gir (https://github.com/gtk-rs/gir)
// from ..
// from ../gir-files
// DO NOT EDIT

use crate::{ffi};
use glib::{translate::*};

glib::wrapper! {
    #[derive(Debug)]
    pub struct Matrix3(Boxed<ffi::GeglMatrix3>);

    match fn {
        copy => |ptr| glib::gobject_ffi::g_boxed_copy(ffi::gegl_matrix3_get_type(), ptr as *mut _) as *mut ffi::GeglMatrix3,
        free => |ptr| glib::gobject_ffi::g_boxed_free(ffi::gegl_matrix3_get_type(), ptr as *mut _),
        type_ => || ffi::gegl_matrix3_get_type(),
    }
}

impl Matrix3 {
    ///
    /// # Returns
    ///
    /// A newly allocated [`Matrix3`][crate::Matrix3]
    #[doc(alias = "gegl_matrix3_new")]
    pub fn new() -> Matrix3 {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(ffi::gegl_matrix3_new())
        }
    }

    /// Copies the matrix in `src` into `self`.
    /// ## `src`
    /// a [`Matrix3`][crate::Matrix3]
    #[doc(alias = "gegl_matrix3_copy_into")]
    pub fn copy_into(&mut self, src: &Matrix3) {
        unsafe {
            ffi::gegl_matrix3_copy_into(self.to_glib_none_mut().0, src.to_glib_none().0);
        }
    }

    /// Returns the determinant for the matrix.
    #[doc(alias = "gegl_matrix3_determinant")]
    pub fn determinant(&self) -> f64 {
        unsafe {
            ffi::gegl_matrix3_determinant(self.to_glib_none().0)
        }
    }

    /// Set the provided `self` to the identity matrix.
    #[doc(alias = "gegl_matrix3_identity")]
    pub fn identity(&mut self) {
        unsafe {
            ffi::gegl_matrix3_identity(self.to_glib_none_mut().0);
        }
    }

    /// Inverts `self`.
    #[doc(alias = "gegl_matrix3_invert")]
    pub fn invert(&mut self) {
        unsafe {
            ffi::gegl_matrix3_invert(self.to_glib_none_mut().0);
        }
    }

    /// Check if a matrix only does an affine transformation.
    ///
    /// Returns TRUE if the matrix only does an affine transformation.
    #[doc(alias = "gegl_matrix3_is_affine")]
    pub fn is_affine(&self) -> bool {
        unsafe {
            from_glib(ffi::gegl_matrix3_is_affine(self.to_glib_none().0))
        }
    }

    /// Check if a matrix is the identity matrix.
    ///
    /// Returns TRUE if the matrix is the identity matrix.
    #[doc(alias = "gegl_matrix3_is_identity")]
    pub fn is_identity(&self) -> bool {
        unsafe {
            from_glib(ffi::gegl_matrix3_is_identity(self.to_glib_none().0))
        }
    }

    /// Check if a matrix only does scaling.
    ///
    /// Returns TRUE if the matrix only does scaling.
    #[doc(alias = "gegl_matrix3_is_scale")]
    pub fn is_scale(&self) -> bool {
        unsafe {
            from_glib(ffi::gegl_matrix3_is_scale(self.to_glib_none().0))
        }
    }

    /// Check if a matrix only does translation.
    ///
    /// Returns TRUE if the matrix only does trasnlation.
    #[doc(alias = "gegl_matrix3_is_translate")]
    pub fn is_translate(&self) -> bool {
        unsafe {
            from_glib(ffi::gegl_matrix3_is_translate(self.to_glib_none().0))
        }
    }

    /// Multiples `product` = `self` Â· `right`
    /// ## `right`
    /// a [`Matrix3`][crate::Matrix3]
    /// ## `product`
    /// a [`Matrix3`][crate::Matrix3] to store the result in.
    #[doc(alias = "gegl_matrix3_multiply")]
    pub fn multiply(&self, right: &Matrix3, product: &mut Matrix3) {
        unsafe {
            ffi::gegl_matrix3_multiply(self.to_glib_none().0, right.to_glib_none().0, product.to_glib_none_mut().0);
        }
    }

    /// Shift the origin of the transformation specified by `self`
    /// to (`x`, `y`). In other words, calculate the matrix that:
    ///
    /// 1. Translates the input by (-`x`, -`y`).
    ///
    /// 2. Transforms the result using the original `self`.
    ///
    /// 3. Translates the result by (`x`, `y`).
    /// ## `x`
    /// x coordinate of new origin
    /// ## `y`
    /// y coordinate of new origin.
    #[doc(alias = "gegl_matrix3_originate")]
    pub fn originate(&mut self, x: f64, y: f64) {
        unsafe {
            ffi::gegl_matrix3_originate(self.to_glib_none_mut().0, x, y);
        }
    }

    /// Parse a transofmation matrix from a string.
    /// ## `string`
    /// a string describing the matrix (right now a small subset of the
    /// transform strings allowed by SVG)
    #[doc(alias = "gegl_matrix3_parse_string")]
    pub fn parse_string(&mut self, string: &str) {
        unsafe {
            ffi::gegl_matrix3_parse_string(self.to_glib_none_mut().0, string.to_glib_none().0);
        }
    }

    /// Rounds numerical errors in `self` to the nearest integer.
    #[doc(alias = "gegl_matrix3_round_error")]
    pub fn round_error(&mut self) {
        unsafe {
            ffi::gegl_matrix3_round_error(self.to_glib_none_mut().0);
        }
    }
}

impl Default for Matrix3 {
                     fn default() -> Self {
                         Self::new()
                     }
                 }
